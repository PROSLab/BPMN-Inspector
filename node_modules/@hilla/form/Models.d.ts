import { BinderNode } from './BinderNode.js';
import type { Validator } from './Validation.js';
export declare const _ItemModel: unique symbol;
export declare const _parent: unique symbol;
export declare const _key: unique symbol;
export declare const _fromString: unique symbol;
export declare const _validators: unique symbol;
export declare const _binderNode: unique symbol;
export declare const _getPropertyModel: unique symbol;
export declare const _enum: unique symbol;
declare const _properties: unique symbol;
declare const _optional: unique symbol;
export declare function getBinderNode<M extends AbstractModel<any>, T = ModelValue<M>>(model: M): BinderNode<T, M>;
export interface HasFromString<T> {
    [_fromString](value: string): T;
}
export declare function hasFromString<T>(model: AbstractModel<T>): model is AbstractModel<T> & HasFromString<T>;
export interface HasValue<T> {
    value?: T;
}
export type ModelParent<T> = AbstractModel<any> | HasValue<T>;
export type ModelValue<M extends AbstractModel<any>> = ReturnType<M['valueOf']>;
export interface ModelConstructor<T, M extends AbstractModel<T>> {
    createEmptyValue: () => T;
    new (parent: ModelParent<T>, key: keyof any, optional: boolean, ...args: any[]): M;
}
type ModelVariableArguments<C extends ModelConstructor<any, AbstractModel<any>>> = C extends new (parent: ModelParent<any>, key: keyof any, ...args: infer R) => any ? R : never;
export declare abstract class AbstractModel<T> {
    static createEmptyValue(): unknown;
    readonly ['constructor']: typeof AbstractModel;
    readonly [_parent]: ModelParent<T>;
    readonly [_validators]: ReadonlyArray<Validator<T>>;
    readonly [_optional]: boolean;
    [_binderNode]?: BinderNode<T, this>;
    [_key]: keyof any;
    constructor(parent: ModelParent<T>, key: keyof any, optional: boolean, ...validators: ReadonlyArray<Validator<T>>);
    toString(): string;
    valueOf(): T;
}
export declare abstract class PrimitiveModel<T> extends AbstractModel<T> {
}
export declare class BooleanModel extends PrimitiveModel<boolean> implements HasFromString<boolean> {
    static createEmptyValue: BooleanConstructor;
    [_fromString](str: string): boolean;
}
export declare class NumberModel extends PrimitiveModel<number> implements HasFromString<number | undefined> {
    static createEmptyValue: NumberConstructor;
    constructor(parent: ModelParent<number>, key: keyof any, optional: boolean, ...validators: ReadonlyArray<Validator<number>>);
    [_fromString](str: string): number | undefined;
}
export declare class StringModel extends PrimitiveModel<string> implements HasFromString<string> {
    static createEmptyValue: StringConstructor;
    [_fromString]: StringConstructor;
}
declare enum Enum {
}
export declare abstract class EnumModel<E extends typeof Enum> extends AbstractModel<E[keyof E]> implements HasFromString<E[keyof E] | undefined> {
    static createEmptyValue(): unknown;
    abstract readonly [_enum]: E;
    [_fromString](value: string): E[keyof E] | undefined;
}
export declare class ObjectModel<T> extends AbstractModel<T> {
    static getOwnAndParentGetters<M extends ObjectModel<any>>(model: M): Generator<readonly [key: string, getter: () => unknown]>;
    static createEmptyValue(): unknown;
    private [_properties];
    protected [_getPropertyModel]<N extends keyof T, C extends new (parent: ModelParent<NonNullable<T[N]>>, key: keyof any, optional: boolean, ...args: any[]) => any>(name: N, ValueModel: C, valueModelArgs: any[]): InstanceType<C>;
}
export declare class ArrayModel<T, M extends AbstractModel<T>> extends AbstractModel<ReadonlyArray<T>> {
    static createEmptyValue(): readonly unknown[];
    private readonly [_ItemModel];
    private readonly itemModelArgs;
    private readonly itemModels;
    constructor(parent: ModelParent<ReadonlyArray<T>>, key: keyof any, optional: boolean, ItemModel: ModelConstructor<T, M>, itemModelArgs: ModelVariableArguments<typeof ItemModel>, ...validators: ReadonlyArray<Validator<ReadonlyArray<T>>>);
    /**
     * Iterates the current array value and yields a binder node for every item.
     */
    [Symbol.iterator](): IterableIterator<BinderNode<T, M>>;
}
export {};
//# sourceMappingURL=Models.d.ts.map
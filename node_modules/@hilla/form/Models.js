// TODO: Fix dependency cycle
var _a, _b, _c, _d, _e, _f, _g, _h;
import isNumeric from 'validator/es/lib/isNumeric.js';
// eslint-disable-next-line import/no-cycle
import { BinderNode } from './BinderNode.js';
import { IsNumber } from './Validators.js';
export const _ItemModel = Symbol('ItemModel');
export const _parent = Symbol('parent');
export const _key = Symbol('key');
export const _fromString = Symbol('fromString');
export const _validators = Symbol('validators');
export const _binderNode = Symbol('binderNode');
export const _getPropertyModel = Symbol('getPropertyModel');
export const _enum = Symbol('enum');
const _properties = Symbol('properties');
const _optional = Symbol('optional');
export function getBinderNode(model) {
    if (!model[_binderNode]) {
        model[_binderNode] = new BinderNode(model);
    }
    return model[_binderNode];
}
export function hasFromString(model) {
    return _fromString in model;
}
export class AbstractModel {
    static createEmptyValue() {
        return undefined;
    }
    constructor(parent, key, optional, ...validators) {
        Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _b, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _c, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _d, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, _e, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this[_parent] = parent;
        this[_key] = key;
        this[_optional] = optional;
        this[_validators] = validators;
    }
    toString() {
        return String(this.valueOf());
    }
    valueOf() {
        const { value } = getBinderNode(this);
        if (value === undefined) {
            throw new TypeError('Value is undefined');
        }
        return value;
    }
}
_a = _parent, _b = _validators, _c = _optional, _d = _binderNode, _e = _key;
export class PrimitiveModel extends AbstractModel {
}
export class BooleanModel extends PrimitiveModel {
    [_fromString](str) {
        // This implementation matches the values accepted by validator.js and converts all other values to false
        // See https://github.com/validatorjs/validator.js/blob/master/src/lib/isBoolean.js
        return ['true', '1', 'yes'].includes(str.toLowerCase());
    }
}
Object.defineProperty(BooleanModel, "createEmptyValue", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Boolean
});
export class NumberModel extends PrimitiveModel {
    constructor(parent, key, optional, ...validators) {
        // Prepend a built-in validator to indicate NaN input
        super(parent, key, optional, new IsNumber(optional), ...validators);
    }
    [_fromString](str) {
        // Returning undefined is needed to support passing the validation when the value of an optional number field is
        // an empty string
        if (str === '')
            return undefined;
        return isNumeric(str) ? Number.parseFloat(str) : NaN;
    }
}
Object.defineProperty(NumberModel, "createEmptyValue", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Number
});
export class StringModel extends PrimitiveModel {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, _f, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: String
        });
    }
}
_f = _fromString;
Object.defineProperty(StringModel, "createEmptyValue", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: String
});
export class EnumModel extends AbstractModel {
    static createEmptyValue() {
        if (this === EnumModel) {
            throw new Error('Cannot create an instance of an abstract class');
        }
        // @ts-expect-error: the instantiation of the abstract class is handled above.
        // Now only the children instantiation could happen.
        const { [_enum]: enumObject } = new this({ value: undefined }, 'value', false);
        return Object.values(enumObject)[0];
    }
    [_fromString](value) {
        return value in this[_enum] ? value : undefined;
    }
}
export class ObjectModel extends AbstractModel {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, _g, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
    }
    static *getOwnAndParentGetters(model) {
        for (let proto = Object.getPrototypeOf(model); proto !== ObjectModel.prototype; proto = Object.getPrototypeOf(proto)) {
            const descriptors = Object.getOwnPropertyDescriptors(proto);
            for (const [name, { get }] of Object.entries(descriptors)) {
                if (get) {
                    yield [name, get];
                }
            }
        }
    }
    static createEmptyValue() {
        const model = new this({ value: undefined }, 'value', false);
        const obj = {};
        // Iterate the model class hierarchy up to the ObjectModel, and extract
        // the property getter names from every prototypes
        for (const [key, getter] of this.getOwnAndParentGetters(model)) {
            const propertyModel = getter.call(model);
            obj[key] = propertyModel[_optional] ? undefined : propertyModel.constructor.createEmptyValue();
        }
        return obj;
    }
    [(_g = _properties, _getPropertyModel)](name, ValueModel, valueModelArgs) {
        const [optional, ...rest] = valueModelArgs;
        if (this[_properties][name] === undefined) {
            this[_properties][name] = new ValueModel(this, name, optional, ...rest);
        }
        return this[_properties][name];
    }
}
export class ArrayModel extends AbstractModel {
    static createEmptyValue() {
        return [];
    }
    constructor(parent, key, optional, ItemModel, itemModelArgs, ...validators) {
        super(parent, key, optional, ...validators);
        Object.defineProperty(this, _h, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "itemModelArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "itemModels", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this[_ItemModel] = ItemModel;
        this.itemModelArgs = itemModelArgs;
    }
    /**
     * Iterates the current array value and yields a binder node for every item.
     */
    *[(_h = _ItemModel, Symbol.iterator)]() {
        const array = this.valueOf();
        const ItemModel = this[_ItemModel];
        if (array.length !== this.itemModels.length) {
            this.itemModels.length = array.length;
        }
        for (const i of array.keys()) {
            let itemModel = this.itemModels[i];
            if (!itemModel) {
                const [optional, ...rest] = this.itemModelArgs;
                itemModel = new ItemModel(this, i, optional, ...rest);
                this.itemModels[i] = itemModel;
            }
            yield getBinderNode(itemModel);
        }
    }
}
//# sourceMappingURL=Models.js.map
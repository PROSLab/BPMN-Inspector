import { noChange, nothing } from 'lit';
import { directive, Directive, PartType } from 'lit/directive.js';
import { _fromString, ArrayModel, ObjectModel, getBinderNode, hasFromString } from './Models.js';
export class AbstractFieldStrategy {
    constructor(element, model) {
        Object.defineProperty(this, "model", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: model
        });
        Object.defineProperty(this, "_element", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => []
        });
        this._element = element;
    }
    get element() {
        return this._element;
    }
    /**
     * @param element the new element value
     * @deprecated will be read-only in future
     */
    set element(element) {
        this._element = element;
    }
    get value() {
        return this.element.value;
    }
    set value(value) {
        this.element.value = value;
    }
    set errorMessage(_) { } // eslint-disable-line @typescript-eslint/no-empty-function
    setAttribute(key, val) {
        if (val) {
            this.element.setAttribute(key, '');
        }
        else {
            this.element.removeAttribute(key);
        }
    }
}
export class VaadinFieldStrategy extends AbstractFieldStrategy {
    set required(value) {
        this.element.required = value;
    }
    set invalid(value) {
        this.element.invalid = value;
    }
    set errorMessage(value) {
        this.element.errorMessage = value;
    }
}
export class GenericFieldStrategy extends AbstractFieldStrategy {
    set required(value) {
        this.setAttribute('required', value);
    }
    set invalid(value) {
        this.setAttribute('invalid', value);
    }
}
export class CheckedFieldStrategy extends GenericFieldStrategy {
    set value(val) {
        this.element.checked = /^(true|on)$/i.test(String(val));
    }
    get value() {
        return this.element.checked;
    }
}
export class ComboBoxFieldStrategy extends VaadinFieldStrategy {
    get value() {
        if (this.model && (this.model instanceof ObjectModel || this.model instanceof ArrayModel)) {
            const { selectedItem } = this.element;
            return selectedItem === null ? undefined : selectedItem;
        }
        return super.value;
    }
    set value(val) {
        if (this.model instanceof ObjectModel || this.model instanceof ArrayModel) {
            this.element.selectedItem = val === undefined ? null : val;
        }
        else {
            super.value = val;
        }
    }
}
export class MultiSelectComboBoxFieldStrategy extends VaadinFieldStrategy {
    get value() {
        return this.element.selectedItems;
    }
    set value(val) {
        this.element.selectedItems = val;
    }
}
export class SelectedFieldStrategy extends GenericFieldStrategy {
    set value(val) {
        this.element.selected = val;
    }
    get value() {
        return this.element.selected;
    }
}
export function getDefaultFieldStrategy(elm, model) {
    switch (elm.localName) {
        case 'vaadin-checkbox':
        case 'vaadin-radio-button':
            return new CheckedFieldStrategy(elm, model);
        case 'vaadin-combo-box':
            return new ComboBoxFieldStrategy(elm, model);
        case 'vaadin-list-box':
            return new SelectedFieldStrategy(elm, model);
        case 'vaadin-multi-select-combo-box':
            return new MultiSelectComboBoxFieldStrategy(elm, model);
        case 'vaadin-rich-text-editor':
            return new GenericFieldStrategy(elm, model);
        default:
            if (elm.localName === 'input' && /^(checkbox|radio)$/.test(elm.type)) {
                return new CheckedFieldStrategy(elm, model);
            }
            return elm.constructor.version ? new VaadinFieldStrategy(elm, model) : new GenericFieldStrategy(elm, model);
    }
}
function convertFieldValue(model, fieldValue) {
    return typeof fieldValue === 'string' && hasFromString(model) ? model[_fromString](fieldValue) : fieldValue;
}
/**
 * Binds a form field component into a model.
 *
 * Example usage:
 *
 * ```
 * <vaadin-text-field ...="${field(model.name)}">
 * </vaadin-text-field>
 * ```
 */
export const field = directive(class extends Directive {
    constructor(partInfo) {
        super(partInfo);
        Object.defineProperty(this, "fieldState", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (partInfo.type !== PartType.PROPERTY && partInfo.type !== PartType.ELEMENT) {
            throw new Error('Use as "<element {field(...)}" or <element ...={field(...)}"');
        }
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    render(model, effect) {
        return nothing;
    }
    update(part, [model, effect]) {
        const element = part.element;
        const binderNode = getBinderNode(model);
        if (!this.fieldState) {
            const fieldState = {
                name: '',
                value: '',
                required: false,
                invalid: false,
                errorMessage: '',
                model,
                element,
                strategy: binderNode.binder.getFieldStrategy(element, model),
            };
            this.fieldState = fieldState;
            const updateValueFromElement = () => {
                fieldState.value = fieldState.strategy.value;
                binderNode.value = convertFieldValue(model, fieldState.value);
                if (effect !== undefined) {
                    effect.call(element, element);
                }
            };
            element.addEventListener('input', updateValueFromElement);
            const changeBlurHandler = () => {
                updateValueFromElement();
                binderNode.visited = true;
            };
            element.addEventListener('blur', changeBlurHandler);
            element.addEventListener('change', changeBlurHandler);
        }
        const { fieldState } = this;
        if (fieldState.element !== element || fieldState.model !== model) {
            fieldState.strategy = binderNode.binder.getFieldStrategy(element, model);
        }
        const { name } = binderNode;
        if (name !== fieldState.name) {
            fieldState.name = name;
            element.setAttribute('name', name);
        }
        const { value } = binderNode;
        const valueFromField = convertFieldValue(model, fieldState.value);
        if (value !== valueFromField && !(Number.isNaN(value) && Number.isNaN(valueFromField))) {
            fieldState.value = value;
            fieldState.strategy.value = value;
        }
        const { required } = binderNode;
        if (required !== fieldState.required) {
            fieldState.required = required;
            fieldState.strategy.required = required;
        }
        const firstError = binderNode.ownErrors ? binderNode.ownErrors[0] : undefined;
        const errorMessage = (firstError && firstError.message) || '';
        if (errorMessage !== fieldState.errorMessage) {
            fieldState.errorMessage = errorMessage;
            fieldState.strategy.errorMessage = errorMessage;
        }
        const { invalid } = binderNode;
        if (invalid !== fieldState.invalid) {
            fieldState.invalid = invalid;
            fieldState.strategy.invalid = invalid;
        }
        return noChange;
    }
});
//# sourceMappingURL=Field.js.map
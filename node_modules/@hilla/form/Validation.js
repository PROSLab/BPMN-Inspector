// TODO: Fix dependency cycle
// eslint-disable-next-line import/no-cycle
import { NumberModel, getBinderNode } from './Models.js';
// eslint-disable-next-line import/no-cycle
import { Required } from './Validators.js';
export class ValidationError extends Error {
    constructor(errors) {
        super([
            'There are validation errors in the form.',
            ...errors.map((e) => `${e.property} - ${e.validator.constructor.name}${e.message ? `: ${e.message}` : ''}`),
        ].join('\n - '));
        Object.defineProperty(this, "errors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: errors
        });
        this.name = this.constructor.name;
    }
}
export class ServerValidator {
    constructor(message) {
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "validate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => false
        });
        this.message = message;
    }
}
// The `property` field of `ValidationResult`s is a path relative to the parent.
function setPropertyAbsolutePath(binderNodeName, result) {
    if (typeof result.property === 'string' && binderNodeName.length > 0) {
        result.property = `${binderNodeName}.${result.property}`;
    }
    return result;
}
export async function runValidator(model, validator, interpolateMessageCallback) {
    const binderNode = getBinderNode(model);
    const value = binderNode.value;
    const interpolateMessage = (message) => {
        if (!interpolateMessageCallback) {
            return message;
        }
        return interpolateMessageCallback(message, validator, binderNode);
    };
    // If model is not required and value empty, do not run any validator. Except
    // always validate NumberModel, which has a mandatory builtin validator
    // to indicate NaN input.
    if (!binderNode.required && !new Required().validate(value) && !(model instanceof NumberModel)) {
        return [];
    }
    return (async () => validator.validate(value, binderNode.binder))().then((result) => {
        if (result === false) {
            return [{ property: binderNode.name, value, validator, message: interpolateMessage(validator.message) }];
        }
        if (result === true || (Array.isArray(result) && result.length === 0)) {
            return [];
        }
        if (Array.isArray(result)) {
            return result.map((result2) => ({
                message: interpolateMessage(validator.message),
                ...setPropertyAbsolutePath(binderNode.name, result2),
                value,
                validator,
            }));
        }
        return [
            {
                message: interpolateMessage(validator.message),
                ...setPropertyAbsolutePath(binderNode.name, result),
                value,
                validator,
            },
        ];
    });
}
//# sourceMappingURL=Validation.js.map
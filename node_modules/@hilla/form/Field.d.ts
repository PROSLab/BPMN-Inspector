import { ElementPart, PropertyPart } from 'lit';
import { PartInfo } from 'lit/directive.js';
import { AbstractModel } from './Models.js';
interface FieldBase<T> {
    required: boolean;
    invalid: boolean;
    errorMessage: string;
    value: T;
}
type FieldElement<T> = Element & FieldBase<T>;
interface FieldElementHolder<T> {
    get element(): FieldElement<T>;
    /**
     * @param element the new element value
     * @deprecated will be read-only in future
     */
    set element(element: FieldElement<T>);
}
interface Field<T> extends FieldBase<T> {
    readonly model?: AbstractModel<T>;
}
interface FieldState<T> extends Field<T>, FieldElementHolder<T> {
    name: string;
    strategy: FieldStrategy<T>;
}
export type FieldStrategy<T = any> = Field<T>;
export declare abstract class AbstractFieldStrategy<T = any> implements FieldStrategy<T> {
    readonly model?: AbstractModel<T> | undefined;
    abstract required: boolean;
    abstract invalid: boolean;
    private _element;
    constructor(element: FieldElement<T>, model?: AbstractModel<T> | undefined);
    get element(): FieldElement<T>;
    /**
     * @param element the new element value
     * @deprecated will be read-only in future
     */
    set element(element: FieldElement<T>);
    validate: () => Promise<never[]>;
    get value(): T;
    set value(value: T);
    set errorMessage(_: string);
    setAttribute(key: string, val: any): void;
}
export declare class VaadinFieldStrategy extends AbstractFieldStrategy {
    set required(value: boolean);
    set invalid(value: boolean);
    set errorMessage(value: string);
}
export declare class GenericFieldStrategy extends AbstractFieldStrategy {
    set required(value: boolean);
    set invalid(value: boolean);
}
export declare class CheckedFieldStrategy extends GenericFieldStrategy {
    set value(val: any);
    get value(): any;
}
export declare class ComboBoxFieldStrategy extends VaadinFieldStrategy {
    get value(): any;
    set value(val: any);
}
export declare class MultiSelectComboBoxFieldStrategy extends VaadinFieldStrategy {
    get value(): any;
    set value(val: any);
}
export declare class SelectedFieldStrategy extends GenericFieldStrategy {
    set value(val: any);
    get value(): any;
}
export declare function getDefaultFieldStrategy<T>(elm: any, model?: AbstractModel<T>): AbstractFieldStrategy<T>;
/**
 * Binds a form field component into a model.
 *
 * Example usage:
 *
 * ```
 * <vaadin-text-field ...="${field(model.name)}">
 * </vaadin-text-field>
 * ```
 */
export declare const field: (model: AbstractModel<any>, effect?: ((element: Element) => void) | undefined) => import("lit/directive.js").DirectiveResult<{
    new (partInfo: PartInfo): {
        fieldState?: FieldState<any> | undefined;
        render(model: AbstractModel<any>, effect?: ((element: Element) => void) | undefined): symbol;
        update(part: PropertyPart | ElementPart, [model, effect]: [model: AbstractModel<any>, effect?: ((element: Element) => void) | undefined]): symbol;
        readonly _$isConnected: boolean;
    };
}>;
export {};
//# sourceMappingURL=Field.d.ts.map
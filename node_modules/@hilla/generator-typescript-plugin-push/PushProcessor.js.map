{"version":3,"file":"PushProcessor.js","sourceRoot":"","sources":["src/PushProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["import createSourceFile from '@hilla/generator-typescript-utils/createSourceFile.js';\nimport DependencyManager from '@hilla/generator-typescript-utils/dependencies/DependencyManager.js';\nimport PathManager from '@hilla/generator-typescript-utils/dependencies/PathManager.js';\nimport ts from 'typescript';\n\nconst initParameterTypeName = 'EndpointRequestInit';\n\nexport default class PushProcessor {\n  readonly #dependencies = new DependencyManager(new PathManager());\n  readonly #methods: readonly string[];\n  readonly #source: ts.SourceFile;\n  readonly #subscriptionId: ts.Identifier;\n\n  constructor(source: ts.SourceFile, methods: readonly string[]) {\n    this.#methods = methods;\n    this.#source = source;\n\n    const { imports, paths } = this.#dependencies;\n\n    this.#dependencies.imports.fromCode(source);\n    this.#subscriptionId = imports.named.add(paths.createBareModulePath('@hilla/frontend', false), 'Subscription');\n  }\n\n  public process(): ts.SourceFile {\n    const importStatements = this.#dependencies.imports.toCode();\n\n    const updatedStatements: readonly ts.Statement[] = [\n      ...importStatements,\n      ...this.#source.statements\n        .filter((statement) => !ts.isImportDeclaration(statement))\n        .map((statement) => {\n          if (ts.isFunctionDeclaration(statement)) {\n            const functionName = statement.name?.text;\n\n            // Checks if the method is in the list of methods to patch\n            if (functionName && this.#methods.includes(functionName)) {\n              return this.#updateFunction(statement);\n            }\n          }\n\n          return statement;\n        }),\n    ];\n\n    return createSourceFile(updatedStatements, this.#source.fileName);\n  }\n\n  #doesInitParameterExist(parameters: ts.NodeArray<ts.ParameterDeclaration>): boolean {\n    const last = parameters[parameters.length - 1];\n    const lastType = last.type as ts.TypeReferenceNode;\n    const lastTypeName = lastType.typeName as ts.Identifier;\n\n    return lastTypeName.text === initParameterTypeName;\n  }\n\n  /**\n   * Replace returned `Promise<Array<T>>` by the `Subscription<T>` type\n   * @param declaration\n   * @private\n   */\n  #replacePromiseType(declaration: ts.FunctionDeclaration) {\n    const promiseType = (declaration.type as ts.TypeReferenceNode).typeArguments![0];\n    const promiseArray = (\n      ts.isUnionTypeNode(promiseType) ? (promiseType as ts.UnionTypeNode).types[0] : promiseType\n    ) as ts.TypeReferenceNode;\n\n    return ts.factory.createTypeReferenceNode(this.#subscriptionId, promiseArray.typeArguments);\n  }\n\n  #updateFunction(declaration: ts.FunctionDeclaration): ts.FunctionDeclaration {\n    const { parameters } = declaration;\n    const doesInitParameterExist = this.#doesInitParameterExist(parameters);\n\n    return ts.factory.createFunctionDeclaration(\n      declaration.decorators,\n      undefined, // no async\n      declaration.asteriskToken,\n      declaration.name,\n      declaration.typeParameters,\n      // Remove the `init` parameter\n      doesInitParameterExist ? parameters.slice(0, -1) : parameters,\n      this.#replacePromiseType(declaration),\n      this.#updateFunctionBody(declaration, doesInitParameterExist),\n    );\n  }\n\n  #updateFunctionBody(declaration: ts.FunctionDeclaration, doesInitParameterExist: boolean): ts.Block {\n    const returnStatement = declaration.body!.statements[0] as ts.ReturnStatement;\n    const { arguments: args, expression, typeArguments } = returnStatement.expression! as ts.CallExpression;\n    const call = expression! as ts.PropertyAccessExpression;\n\n    return ts.factory.createBlock([\n      ts.factory.createReturnStatement(\n        ts.factory.createCallExpression(\n          ts.factory.createPropertyAccessExpression(\n            call.expression,\n            // `subscribe` instead of `call`\n            ts.factory.createIdentifier('subscribe'),\n          ),\n          typeArguments,\n          // remove the `init` parameter\n          doesInitParameterExist ? args.slice(0, -1) : args,\n        ),\n      ),\n    ]);\n  }\n}\n"]}
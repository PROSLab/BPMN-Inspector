import createSourceFile from '@hilla/generator-typescript-utils/createSourceFile.js';
import DependencyManager from '@hilla/generator-typescript-utils/dependencies/DependencyManager.js';
import PathManager from '@hilla/generator-typescript-utils/dependencies/PathManager.js';
import ts from 'typescript';
const initParameterTypeName = 'EndpointRequestInit';
export default class PushProcessor {
    #dependencies = new DependencyManager(new PathManager());
    #methods;
    #source;
    #subscriptionId;
    constructor(source, methods) {
        this.#methods = methods;
        this.#source = source;
        const { imports, paths } = this.#dependencies;
        this.#dependencies.imports.fromCode(source);
        this.#subscriptionId = imports.named.add(paths.createBareModulePath('@hilla/frontend', false), 'Subscription');
    }
    process() {
        const importStatements = this.#dependencies.imports.toCode();
        const updatedStatements = [
            ...importStatements,
            ...this.#source.statements
                .filter((statement) => !ts.isImportDeclaration(statement))
                .map((statement) => {
                if (ts.isFunctionDeclaration(statement)) {
                    const functionName = statement.name?.text;
                    // Checks if the method is in the list of methods to patch
                    if (functionName && this.#methods.includes(functionName)) {
                        return this.#updateFunction(statement);
                    }
                }
                return statement;
            }),
        ];
        return createSourceFile(updatedStatements, this.#source.fileName);
    }
    #doesInitParameterExist(parameters) {
        const last = parameters[parameters.length - 1];
        const lastType = last.type;
        const lastTypeName = lastType.typeName;
        return lastTypeName.text === initParameterTypeName;
    }
    /**
     * Replace returned `Promise<Array<T>>` by the `Subscription<T>` type
     * @param declaration
     * @private
     */
    #replacePromiseType(declaration) {
        const promiseType = declaration.type.typeArguments[0];
        const promiseArray = (ts.isUnionTypeNode(promiseType) ? promiseType.types[0] : promiseType);
        return ts.factory.createTypeReferenceNode(this.#subscriptionId, promiseArray.typeArguments);
    }
    #updateFunction(declaration) {
        const { parameters } = declaration;
        const doesInitParameterExist = this.#doesInitParameterExist(parameters);
        return ts.factory.createFunctionDeclaration(declaration.decorators, undefined, // no async
        declaration.asteriskToken, declaration.name, declaration.typeParameters, 
        // Remove the `init` parameter
        doesInitParameterExist ? parameters.slice(0, -1) : parameters, this.#replacePromiseType(declaration), this.#updateFunctionBody(declaration, doesInitParameterExist));
    }
    #updateFunctionBody(declaration, doesInitParameterExist) {
        const returnStatement = declaration.body.statements[0];
        const { arguments: args, expression, typeArguments } = returnStatement.expression;
        const call = expression;
        return ts.factory.createBlock([
            ts.factory.createReturnStatement(ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(call.expression, 
            // `subscribe` instead of `call`
            ts.factory.createIdentifier('subscribe')), typeArguments, 
            // remove the `init` parameter
            doesInitParameterExist ? args.slice(0, -1) : args)),
        ]);
    }
}
//# sourceMappingURL=PushProcessor.js.map
{"version":3,"file":"TypeSchemaProcessor.js","sourceRoot":"","sources":["src/TypeSchemaProcessor.ts"],"names":[],"mappings":"AAAA,OAAO,EAEL,4BAA4B,EAC5B,iCAAiC,EACjC,eAAe,EACf,aAAa,EACb,eAAe,EACf,gBAAgB,EAChB,eAAe,EACf,WAAW,EACX,gBAAgB,EAChB,cAAc,EACd,iBAAiB,EACjB,cAAc,GAKf,MAAM,4CAA4C,CAAC;AAGpD,OAAO,EAAE,MAAM,YAAY,CAAC;AAE5B,SAAS,aAAa;IACpB,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;AACxE,CAAC;AAED,SAAS,YAAY;IACnB,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AACvE,CAAC;AAED,SAAS,YAAY;IACnB,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC,CAAC;AACvE,CAAC;AAED,SAAS,eAAe;IACtB,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,gBAAgB,CAAC,CAAC;AAC1E,CAAC;AAED,SAAS,aAAa;IACpB,OAAO,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;AACxE,CAAC;AAED,SAAS,4BAA4B,CAAC,MAAc;IAClD,IAAI,gBAAgB,CAAC,MAAM,CAAC,EAAE;QAC5B,MAAM,CAAC,MAAM,CAAC,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;QAEzC,OAAO,MAA2B,CAAC;KACpC;IAED,OAAO,MAA2B,CAAC;AACrC,CAAC;AAED,MAAM,CAAC,OAAO,OAAO,mBAAmB;IAE7B,aAAa,CAAoB;IACjC,OAAO,CAAS;IAEzB,YAAmB,MAAc,EAAE,YAA+B;QAChE,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,aAAa,GAAG,YAAY,CAAC;IACpC,CAAC;IAEM,OAAO;QACZ,IAAI,IAAc,CAAC;QAEnB,MAAM,eAAe,GAAG,4BAA4B,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAEnE,IAAI,iBAAiB,CAAC,eAAe,CAAC,EAAE;YACtC,IAAI,GAAG,IAAI,CAAC,iBAAiB,CAAC,eAAe,CAAC,CAAC;SAChD;aAAM,IAAI,aAAa,CAAC,eAAe,CAAC,EAAE;YACzC,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,CAAC;SAC5C;aAAM,IAAI,WAAW,CAAC,eAAe,CAAC,EAAE;YACvC,IAAI,GAAG,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC;SAC1C;aAAM,IAAI,eAAe,CAAC,eAAe,CAAC,EAAE;YAC3C,IAAI,GAAG,aAAa,EAAE,CAAC;SACxB;aAAM,IAAI,eAAe,CAAC,eAAe,CAAC,IAAI,cAAc,CAAC,eAAe,CAAC,EAAE;YAC9E,IAAI,GAAG,YAAY,EAAE,CAAC;SACvB;aAAM,IAAI,cAAc,CAAC,eAAe,CAAC,EAAE;YAC1C,IAAI,GAAG,YAAY,EAAE,CAAC;SACvB;aAAM;YACL,IAAI,GAAG,aAAa,EAAE,CAAC;SACxB;QAED,OAAO,gBAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,eAAe,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;IAC7E,CAAC;IAED,aAAa,CAAC,MAAmB;QAC/B,MAAM,KAAK,GAAG,IAAI,mBAAmB,CAAC,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,EAAE,CAAC;QAElF,OAAO,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9F,CAAC;IAED,WAAW,CAAC,EAAE,oBAAoB,EAAE,UAAU,EAAa;QACzD,IAAI,cAAwB,CAAC;QAE7B,IAAI,OAAO,UAAU,KAAK,SAAS,EAAE;YACnC,MAAM,KAAK,GAAG,IAAI,mBAAmB,CAAC,UAAU,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC,OAAO,EAAE,CAAC;YAChF,cAAc,GAAG,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,CAAC;SACxD;aAAM;YACL,cAAc,GAAG,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;SACjF;QAED,OAAO,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAAC,QAAQ,EAAE;YAClD,EAAE,CAAC,OAAO,CAAC,qBAAqB,CAAC,EAAE,CAAC,UAAU,CAAC,aAAa,CAAC;YAC7D,cAAc;SACf,CAAC,CAAC;IACL,CAAC;IAED,iBAAiB,CAAC,MAAuB;QACvC,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,aAAa,CAAC;QAE9C,MAAM,SAAS,GAAG,iCAAiC,CAAC,MAAM,CAAC,CAAC;QAC5D,MAAM,IAAI,GAAG,KAAK,CAAC,kBAAkB,CAAC,4BAA4B,CAAC,MAAM,CAAC,CAAC,CAAC;QAE5E,MAAM,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;QAErG,OAAO,EAAE,CAAC,OAAO,CAAC,uBAAuB,CAAC,UAAU,CAAC,CAAC;IACxD,CAAC;CACF","sourcesContent":["import {\n  ArraySchema,\n  convertReferenceSchemaToPath,\n  convertReferenceSchemaToSpecifier,\n  decomposeSchema,\n  isArraySchema,\n  isBooleanSchema,\n  isComposedSchema,\n  isIntegerSchema,\n  isMapSchema,\n  isNullableSchema,\n  isNumberSchema,\n  isReferenceSchema,\n  isStringSchema,\n  MapSchema,\n  NonComposedSchema,\n  ReferenceSchema,\n  Schema,\n} from '@hilla/generator-typescript-core/Schema.js';\nimport type DependencyManager from '@hilla/generator-typescript-utils/dependencies/DependencyManager.js';\nimport type { TypeNode } from 'typescript';\nimport ts from 'typescript';\n\nfunction createBoolean(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n}\n\nfunction createNumber(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n}\n\nfunction createString(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n}\n\nfunction createUndefined(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\n}\n\nfunction createUnknown(): TypeNode {\n  return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n}\n\nfunction unwrapPossiblyNullableSchema(schema: Schema): NonComposedSchema {\n  if (isComposedSchema(schema)) {\n    const [result] = decomposeSchema(schema);\n\n    return result as NonComposedSchema;\n  }\n\n  return schema as NonComposedSchema;\n}\n\nexport default class TypeSchemaProcessor {\n  public declare ['constructor']: typeof TypeSchemaProcessor;\n  readonly #dependencies: DependencyManager;\n  readonly #schema: Schema;\n\n  public constructor(schema: Schema, dependencies: DependencyManager) {\n    this.#schema = schema;\n    this.#dependencies = dependencies;\n  }\n\n  public process(): readonly TypeNode[] {\n    let node: TypeNode;\n\n    const unwrappedSchema = unwrapPossiblyNullableSchema(this.#schema);\n\n    if (isReferenceSchema(unwrappedSchema)) {\n      node = this.#processReference(unwrappedSchema);\n    } else if (isArraySchema(unwrappedSchema)) {\n      node = this.#processArray(unwrappedSchema);\n    } else if (isMapSchema(unwrappedSchema)) {\n      node = this.#processMap(unwrappedSchema);\n    } else if (isBooleanSchema(unwrappedSchema)) {\n      node = createBoolean();\n    } else if (isIntegerSchema(unwrappedSchema) || isNumberSchema(unwrappedSchema)) {\n      node = createNumber();\n    } else if (isStringSchema(unwrappedSchema)) {\n      node = createString();\n    } else {\n      node = createUnknown();\n    }\n\n    return isNullableSchema(this.#schema) ? [node, createUndefined()] : [node];\n  }\n\n  #processArray(schema: ArraySchema): TypeNode {\n    const nodes = new TypeSchemaProcessor(schema.items, this.#dependencies).process();\n\n    return ts.factory.createTypeReferenceNode('Array', [ts.factory.createUnionTypeNode(nodes)]);\n  }\n\n  #processMap({ additionalProperties: valuesType }: MapSchema): TypeNode {\n    let valuesTypeNode: TypeNode;\n\n    if (typeof valuesType !== 'boolean') {\n      const nodes = new TypeSchemaProcessor(valuesType, this.#dependencies).process();\n      valuesTypeNode = ts.factory.createUnionTypeNode(nodes);\n    } else {\n      valuesTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n    }\n\n    return ts.factory.createTypeReferenceNode('Record', [\n      ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),\n      valuesTypeNode,\n    ]);\n  }\n\n  #processReference(schema: ReferenceSchema): TypeNode {\n    const { imports, paths } = this.#dependencies;\n\n    const specifier = convertReferenceSchemaToSpecifier(schema);\n    const path = paths.createRelativePath(convertReferenceSchemaToPath(schema));\n\n    const identifier = imports.default.getIdentifier(path) ?? imports.default.add(path, specifier, true);\n\n    return ts.factory.createTypeReferenceNode(identifier);\n  }\n}\n"]}
import { convertReferenceSchemaToPath, convertReferenceSchemaToSpecifier, decomposeSchema, isArraySchema, isBooleanSchema, isComposedSchema, isIntegerSchema, isMapSchema, isNullableSchema, isNumberSchema, isReferenceSchema, isStringSchema, } from '@hilla/generator-typescript-core/Schema.js';
import ts from 'typescript';
function createBoolean() {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
}
function createNumber() {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
}
function createString() {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
}
function createUndefined() {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);
}
function createUnknown() {
    return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
}
function unwrapPossiblyNullableSchema(schema) {
    if (isComposedSchema(schema)) {
        const [result] = decomposeSchema(schema);
        return result;
    }
    return schema;
}
export default class TypeSchemaProcessor {
    #dependencies;
    #schema;
    constructor(schema, dependencies) {
        this.#schema = schema;
        this.#dependencies = dependencies;
    }
    process() {
        let node;
        const unwrappedSchema = unwrapPossiblyNullableSchema(this.#schema);
        if (isReferenceSchema(unwrappedSchema)) {
            node = this.#processReference(unwrappedSchema);
        }
        else if (isArraySchema(unwrappedSchema)) {
            node = this.#processArray(unwrappedSchema);
        }
        else if (isMapSchema(unwrappedSchema)) {
            node = this.#processMap(unwrappedSchema);
        }
        else if (isBooleanSchema(unwrappedSchema)) {
            node = createBoolean();
        }
        else if (isIntegerSchema(unwrappedSchema) || isNumberSchema(unwrappedSchema)) {
            node = createNumber();
        }
        else if (isStringSchema(unwrappedSchema)) {
            node = createString();
        }
        else {
            node = createUnknown();
        }
        return isNullableSchema(this.#schema) ? [node, createUndefined()] : [node];
    }
    #processArray(schema) {
        const nodes = new TypeSchemaProcessor(schema.items, this.#dependencies).process();
        return ts.factory.createTypeReferenceNode('Array', [ts.factory.createUnionTypeNode(nodes)]);
    }
    #processMap({ additionalProperties: valuesType }) {
        let valuesTypeNode;
        if (typeof valuesType !== 'boolean') {
            const nodes = new TypeSchemaProcessor(valuesType, this.#dependencies).process();
            valuesTypeNode = ts.factory.createUnionTypeNode(nodes);
        }
        else {
            valuesTypeNode = ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
        }
        return ts.factory.createTypeReferenceNode('Record', [
            ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
            valuesTypeNode,
        ]);
    }
    #processReference(schema) {
        const { imports, paths } = this.#dependencies;
        const specifier = convertReferenceSchemaToSpecifier(schema);
        const path = paths.createRelativePath(convertReferenceSchemaToPath(schema));
        const identifier = imports.default.getIdentifier(path) ?? imports.default.add(path, specifier, true);
        return ts.factory.createTypeReferenceNode(identifier);
    }
}
//# sourceMappingURL=TypeSchemaProcessor.js.map
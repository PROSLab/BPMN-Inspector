import Plugin from '@hilla/generator-typescript-core/Plugin.js';
import EndpointProcessor from './EndpointProcessor.js';
import { EntityProcessor } from './EntityProcessor.js';
export var BackbonePluginSourceType;
(function (BackbonePluginSourceType) {
    BackbonePluginSourceType["Endpoint"] = "endpoint";
    BackbonePluginSourceType["Entity"] = "entity";
})(BackbonePluginSourceType || (BackbonePluginSourceType = {}));
export default class BackbonePlugin extends Plugin {
    static BACKBONE_PLUGIN_FILE_TAGS = 'BACKBONE_PLUGIN_FILE_TAGS';
    #tags = new WeakMap();
    get path() {
        return import.meta.url;
    }
    async execute(storage) {
        const endpointSourceFiles = await this.#processEndpoints(storage);
        const entitySourceFiles = this.#processEntities(storage);
        endpointSourceFiles.forEach((file) => this.#tags.set(file, BackbonePluginSourceType.Endpoint));
        entitySourceFiles.forEach((file) => this.#tags.set(file, BackbonePluginSourceType.Entity));
        storage.sources.push(...endpointSourceFiles, ...entitySourceFiles);
        storage.pluginStorage.set(this.constructor.BACKBONE_PLUGIN_FILE_TAGS, this.#tags);
    }
    async #processEndpoints(storage) {
        this.logger.debug('Processing endpoints');
        const endpoints = new Map();
        Object.entries(storage.api.paths)
            .filter(([, pathItem]) => !!pathItem)
            .forEach(([path, pathItem]) => {
            const [, endpointName, endpointMethodName] = path.split('/');
            let methods;
            if (endpoints.has(endpointName)) {
                methods = endpoints.get(endpointName);
            }
            else {
                methods = new Map();
                endpoints.set(endpointName, methods);
            }
            methods.set(endpointMethodName, pathItem);
        });
        const processors = await Promise.all([...endpoints.entries()].map(([endpointName, methods]) => EndpointProcessor.create(endpointName, this, methods, storage.outputDir)));
        return Promise.all(processors.map((processor) => processor.process()));
    }
    #processEntities(storage) {
        this.logger.debug('Processing entities');
        return storage.api.components?.schemas
            ? Object.entries(storage.api.components?.schemas).map(([name, component]) => new EntityProcessor(name, component, this).process())
            : [];
    }
}
//# sourceMappingURL=index.js.map
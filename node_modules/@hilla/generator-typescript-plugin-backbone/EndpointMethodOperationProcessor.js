import ClientPlugin from '@hilla/generator-typescript-plugin-client';
import equal from 'fast-deep-equal';
import { OpenAPIV3 } from 'openapi-types';
import ts from 'typescript';
import EndpointMethodRequestBodyProcessor from './EndpointMethodRequestBodyProcessor.js';
import EndpointMethodResponseProcessor from './EndpointMethodResponseProcessor.js';
export const INIT_TYPE_NAME = 'EndpointRequestInit';
export const HILLA_FRONTEND_NAME = '@hilla/frontend';
export default class EndpointMethodOperationProcessor {
    static createProcessor(httpMethod, endpointName, endpointMethodName, operation, dependencies, owner) {
        switch (httpMethod) {
            case OpenAPIV3.HttpMethods.POST:
                // eslint-disable-next-line no-use-before-define
                return new EndpointMethodOperationPOSTProcessor(endpointName, endpointMethodName, operation, dependencies, owner);
            default:
                owner.logger.warn(`Processing ${httpMethod.toUpperCase()} currently is not supported`);
                return undefined;
        }
    }
}
class EndpointMethodOperationPOSTProcessor extends EndpointMethodOperationProcessor {
    #dependencies;
    #endpointMethodName;
    #endpointName;
    #operation;
    #owner;
    constructor(endpointName, endpointMethodName, operation, dependencies, owner) {
        super();
        this.#owner = owner;
        this.#dependencies = dependencies;
        this.#endpointName = endpointName;
        this.#endpointMethodName = endpointMethodName;
        this.#operation = operation;
    }
    async process(outputDir) {
        const { exports, imports, paths } = this.#dependencies;
        this.#owner.logger.debug(`${this.#endpointName}.${this.#endpointMethodName} - processing POST method`);
        const initTypeIdentifier = imports.named.getIdentifier(paths.createBareModulePath(HILLA_FRONTEND_NAME), INIT_TYPE_NAME);
        const { parameters, packedParameters, initParam } = new EndpointMethodRequestBodyProcessor(this.#operation.requestBody, this.#dependencies, this.#owner, initTypeIdentifier).process();
        const methodIdentifier = exports.named.add(this.#endpointMethodName);
        const clientLibIdentifier = imports.default.getIdentifier(paths.createRelativePath(await ClientPlugin.getClientFileName(outputDir)));
        const callExpression = ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(clientLibIdentifier, ts.factory.createIdentifier('call')), undefined, [
            ts.factory.createStringLiteral(this.#endpointName),
            ts.factory.createStringLiteral(this.#endpointMethodName),
            packedParameters,
            initParam,
        ].filter(Boolean));
        const responseType = this.#prepareResponseType();
        return ts.factory.createFunctionDeclaration(undefined, [ts.factory.createToken(ts.SyntaxKind.AsyncKeyword)], undefined, methodIdentifier, undefined, parameters, ts.factory.createTypeReferenceNode('Promise', [responseType]), ts.factory.createBlock([ts.factory.createReturnStatement(callExpression)]));
    }
    #prepareResponseType() {
        this.#owner.logger.debug(`${this.#endpointName}.${this.#endpointMethodName} POST - processing response type`);
        const responseTypes = Object.entries(this.#operation.responses)
            .flatMap(([code, response]) => new EndpointMethodResponseProcessor(code, response, this.#dependencies, this.#owner).process())
            .filter((value, index, arr) => arr.findIndex((v) => equal(v, value)) === index);
        if (responseTypes.length === 0) {
            return ts.factory.createKeywordTypeNode(ts.SyntaxKind.VoidKeyword);
        }
        return ts.factory.createUnionTypeNode(responseTypes);
    }
}
//# sourceMappingURL=EndpointMethodOperationProcessor.js.map
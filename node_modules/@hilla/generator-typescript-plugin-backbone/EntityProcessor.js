import { convertReferenceSchemaToPath, convertReferenceSchemaToSpecifier, decomposeSchema, isComposedSchema, isEmptyObject, isEnumSchema, isNullableSchema, isObjectSchema, isReferenceSchema, } from '@hilla/generator-typescript-core/Schema.js';
import { convertFullyQualifiedNameToRelativePath, simplifyFullyQualifiedName, } from '@hilla/generator-typescript-core/utils.js';
import createSourceFile from '@hilla/generator-typescript-utils/createSourceFile.js';
import DependencyManager from '@hilla/generator-typescript-utils/dependencies/DependencyManager.js';
import PathManager from '@hilla/generator-typescript-utils/dependencies/PathManager.js';
import { dirname } from 'path/posix';
import ts from 'typescript';
import TypeSchemaProcessor from './TypeSchemaProcessor.js';
export class EntityProcessor {
    #component;
    #dependencies;
    #fullyQualifiedName;
    #name;
    #owner;
    #path;
    #sourcePaths = new PathManager({ extension: 'ts' });
    constructor(name, component, owner) {
        this.#component = component;
        this.#owner = owner;
        this.#fullyQualifiedName = name;
        this.#name = simplifyFullyQualifiedName(name);
        this.#path = convertFullyQualifiedNameToRelativePath(name);
        this.#dependencies = new DependencyManager(new PathManager({ relativeTo: dirname(this.#path) }));
    }
    get #id() {
        const id = ts.factory.createIdentifier(this.#name);
        this.#dependencies.exports.default.set(id);
        return id;
    }
    process() {
        this.#owner.logger.debug(`Processing entity: ${this.#name}`);
        const declaration = isEnumSchema(this.#component)
            ? this.#processEnum(this.#component)
            : this.#processExtendedClass(this.#component);
        const statements = declaration ? [declaration] : [];
        const { imports, exports } = this.#dependencies;
        return createSourceFile([...imports.toCode(), ...statements, ...exports.toCode()], this.#sourcePaths.createRelativePath(this.#path));
    }
    #processClass(schema) {
        const { logger } = this.#owner;
        if (!isObjectSchema(schema)) {
            logger.error(schema, `Component is not an object: '${this.#fullyQualifiedName}'`);
            return undefined;
        }
        if (isEmptyObject(schema)) {
            logger.warn(`Component has no properties:' ${this.#fullyQualifiedName}'`);
        }
        return ts.factory.createInterfaceDeclaration(undefined, undefined, this.#id, undefined, undefined, this.#processTypeElements(schema));
    }
    #processEnum({ enum: members }) {
        return ts.factory.createEnumDeclaration(undefined, undefined, this.#id, members.map((member) => ts.factory.createEnumMember(member, ts.factory.createStringLiteral(member))) ?? []);
    }
    #processExtendedClass(schema) {
        const { logger } = this.#owner;
        if (isComposedSchema(schema)) {
            const decomposed = decomposeSchema(schema);
            if (decomposed.length > 2) {
                logger.error(schema, `Schema for '${this.#fullyQualifiedName}' class component is broken.`);
                return undefined;
            }
            const [parent, child] = decomposed;
            if (!isReferenceSchema(parent)) {
                logger.error(parent, 'Only reference schema allowed for parent class');
                return undefined;
            }
            const declaration = this.#processClass(child);
            const identifier = this.#processParentClass(parent);
            return (declaration &&
                ts.factory.updateInterfaceDeclaration(declaration, undefined, declaration.modifiers, declaration.name, undefined, [
                    ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [
                        ts.factory.createExpressionWithTypeArguments(identifier, undefined),
                    ]),
                ], declaration.members));
        }
        return this.#processClass(schema);
    }
    #processParentClass(schema) {
        const { imports, paths } = this.#dependencies;
        const specifier = convertReferenceSchemaToSpecifier(schema);
        const path = paths.createRelativePath(convertReferenceSchemaToPath(schema));
        return imports.default.add(path, specifier, true);
    }
    #processTypeElements({ properties }) {
        return properties
            ? Object.entries(properties).map(([name, schema]) => {
                const [type] = new TypeSchemaProcessor(schema, this.#dependencies).process();
                return ts.factory.createPropertySignature(undefined, name, isNullableSchema(schema) ? ts.factory.createToken(ts.SyntaxKind.QuestionToken) : undefined, type);
            })
            : [];
    }
}
//# sourceMappingURL=EntityProcessor.js.map
import Plugin from '@hilla/generator-typescript-core/Plugin.js';
import { access, mkdir, readFile, rm, writeFile } from 'fs/promises';
import { createRequire } from 'module';
import { dirname, isAbsolute, join, resolve } from 'path';
import { pathToFileURL } from 'url';
import { constants } from 'fs';
import GeneratorIOException from './GeneratorIOException.js';
export default class GeneratorIO {
    cwd;
    static INDEX_FILENAME = 'generated-file-list.txt';
    #logger;
    #outputDir;
    #require;
    constructor(outputDir, logger) {
        this.cwd = process.cwd();
        this.#outputDir = isAbsolute(outputDir) ? outputDir : resolve(this.cwd, outputDir);
        this.#logger = logger;
        this.#require = createRequire(import.meta.url);
        logger.global.info(`Output directory: ${this.#outputDir}`);
    }
    /**
     * Cleans the output directory by removing all files that had been generated last time.
     * A list of those files is found in {@link GeneratorIO.INDEX_FILENAME}.
     * @return a set containing deleted filenames
     */
    async cleanOutputDir() {
        this.#logger.global.debug(`Cleaning ${this.#outputDir} up.`);
        await mkdir(this.#outputDir, { recursive: true });
        const indexFile = resolve(this.#outputDir, GeneratorIO.INDEX_FILENAME);
        const deletedFiles = new Set();
        try {
            const indexFileContents = await this.read(indexFile);
            const filesToDelete = indexFileContents.split('\n').filter((n) => n.length);
            await Promise.all(filesToDelete.map(async (filename) => {
                this.#logger.global.debug(`Deleting file ${filename}.`);
                await rm(join(this.#outputDir, filename));
                deletedFiles.add(filename);
            }));
            this.#logger.global.debug(`Deleting index file ${indexFile}.`);
            await rm(indexFile);
        }
        catch (err) {
            // non-existing file is OK, all other errors must be rethrown
            if (err.code !== 'ENOENT') {
                throw err;
            }
        }
        return deletedFiles;
    }
    async createFileIndex(filenames) {
        const path = join(this.#outputDir, GeneratorIO.INDEX_FILENAME);
        await writeFile(path, filenames.join('\n'), 'utf-8');
    }
    async loadPlugin(modulePath) {
        this.#logger.global.debug(`Loading plugin: ${modulePath}`);
        const resolved = pathToFileURL(this.#require.resolve(modulePath));
        const cls = (await import(resolved.toString())).default;
        if (!Object.prototype.isPrototypeOf.call(Plugin, cls)) {
            throw new GeneratorIOException(`Plugin '${modulePath}' is not an instance of a Plugin class`);
        }
        return cls;
    }
    async read(path) {
        this.#logger.global.debug(`Reading file: ${path}`);
        return readFile(path, 'utf8');
    }
    async write(file) {
        const filePath = join(this.#outputDir, file.name);
        this.#logger.global.debug(`Writing file ${filePath}.`);
        const dir = dirname(filePath);
        await mkdir(dir, { recursive: true });
        return writeFile(filePath, new Uint8Array(await file.arrayBuffer()));
    }
    /**
     * Checks that a file exists (is visible)
     * @param path the file path to check
     */
    exists(path) {
        return new Promise((res, _rej) => {
            return access(path, constants.F_OK).then(() => {
                res(true);
            }, () => {
                res(false);
            });
        });
    }
}
//# sourceMappingURL=GeneratorIO.js.map
/* eslint-disable max-classes-per-file */
import { ConnectionIndicator, ConnectionState } from '@vaadin/common-frontend';
import { getCsrfTokenHeadersForEndpointRequest } from './CsrfUtils.js';
import { FluxConnection } from './FluxConnection.js';
const $wnd = window;
/* c8 ignore next 2 */
$wnd.Vaadin = $wnd.Vaadin || {};
$wnd.Vaadin.registrations = $wnd.Vaadin.registrations || [];
$wnd.Vaadin.registrations.push({
    is: 'endpoint',
});
/**
 * An exception that gets thrown when the Vaadin backend responds
 * with not ok status.
 */
export class EndpointError extends Error {
    /**
     * @param message the `message` property value
     * @param type the `type` property value
     * @param detail the `detail` property value
     */
    constructor(message, type, detail) {
        super(message);
        /**
         * The optional name of the exception that was thrown on a backend
         */
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The optional detail object, containing additional information sent
         * from a backend
         */
        Object.defineProperty(this, "detail", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.type = type;
        this.detail = detail;
    }
}
/**
 * An exception that gets thrown if Vaadin endpoint responds
 * with non-ok status and provides additional info
 * on the validation errors occurred.
 */
export class EndpointValidationError extends EndpointError {
    /**
     * @param message the `message` property value
     * @param validationErrorData the `validationErrorData` property value
     * @param type the `type` property value
     */
    constructor(message, validationErrorData, type) {
        super(message, type, validationErrorData);
        /**
         * An original validation error message.
         */
        Object.defineProperty(this, "validationErrorMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * An array of the validation errors.
         */
        Object.defineProperty(this, "validationErrorData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.validationErrorMessage = message;
        this.detail = null;
        this.validationErrorData = validationErrorData;
    }
}
/**
 * An exception that gets thrown for unexpected HTTP response.
 */
export class EndpointResponseError extends EndpointError {
    /**
     * @param message the `message` property value
     * @param response the `response` property value
     */
    constructor(message, response) {
        super(message, 'EndpointResponseError', response);
        /**
         * The optional response object, containing the HTTP response error
         */
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.response = response;
    }
    /**
     * Convenience property to get the HTTP code status directly
     */
    get status() {
        return this.response.status;
    }
}
export class UnauthorizedResponseError extends EndpointResponseError {
    constructor(message, response) {
        super(message, response);
        this.type = 'UnauthorizedResponseError';
    }
}
export class ForbiddenResponseError extends EndpointResponseError {
    constructor(message, response) {
        super(message, response);
        this.type = 'ForbiddenResponseError';
    }
}
const throwConnectException = (errorJson) => {
    if (errorJson.validationErrorData) {
        throw new EndpointValidationError(errorJson.message, errorJson.validationErrorData, errorJson.type);
    }
    else {
        throw new EndpointError(errorJson.message, errorJson.type, errorJson.detail);
    }
};
/**
 * Throws a TypeError if the response is not 200 OK.
 * @param response The response to assert.
 * @ignore
 */
const assertResponseIsOk = async (response) => {
    if (!response.ok) {
        const errorText = await response.text();
        let errorJson;
        try {
            errorJson = JSON.parse(errorText);
        }
        catch (ignored) {
            // not a json
            errorJson = null;
        }
        if (errorJson !== null) {
            throwConnectException(errorJson);
        }
        else if (errorText !== null && errorText.length > 0) {
            throw new EndpointResponseError(errorText, response);
        }
        else {
            const message = `expected "200 OK" response, but got ${response.status} ${response.statusText}`;
            switch (response.status) {
                case 401:
                    throw new UnauthorizedResponseError(message, response);
                case 403:
                    throw new ForbiddenResponseError(message, response);
                default:
                    throw new EndpointResponseError(message, response);
            }
        }
    }
};
/**
 * An object, containing all data for the particular validation error.
 */
export class ValidationErrorData {
    /**
     * @param message the `message` property value
     * @param parameterName the `parameterName` property value
     */
    constructor(message, parameterName) {
        /**
         * The validation error message.
         */
        Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The parameter name that caused the validation error.
         */
        Object.defineProperty(this, "parameterName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.message = message;
        this.parameterName = parameterName;
    }
}
function isFlowLoaded() {
    var _a, _b;
    return ((_b = (_a = $wnd.Vaadin.Flow) === null || _a === void 0 ? void 0 : _a.clients) === null || _b === void 0 ? void 0 : _b.TypeScript) !== undefined;
}
/**
 * A low-level network calling utility. It stores
 * a prefix and facilitates remote calls to endpoint class methods
 * on the Hilla backend.
 *
 * Example usage:
 *
 * ```js
 * const client = new ConnectClient();
 * const responseData = await client.call('MyEndpoint', 'myMethod');
 * ```
 *
 * ### Prefix
 *
 * The client supports an `prefix` constructor option:
 * ```js
 * const client = new ConnectClient({prefix: '/my-connect-prefix'});
 * ```
 *
 * The default prefix is '/connect'.
 *
 */
export class ConnectClient {
    /**
     * @param options Constructor options.
     */
    constructor(options = {}) {
        /**
         * The Hilla endpoint prefix
         */
        Object.defineProperty(this, "prefix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: '/connect'
        });
        /**
         * The array of middlewares that are invoked during a call.
         */
        Object.defineProperty(this, "middlewares", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "_fluxConnection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        if (options.prefix) {
            this.prefix = options.prefix;
        }
        if (options.middlewares) {
            this.middlewares = options.middlewares;
        }
        // add connection indicator to DOM
        ConnectionIndicator.create();
        // Listen to browser online/offline events and update the loading indicator accordingly.
        // Note: if Flow.ts is loaded, it instead handles the state transitions.
        $wnd.addEventListener('online', () => {
            if (!isFlowLoaded()) {
                $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTED;
            }
        });
        $wnd.addEventListener('offline', () => {
            if (!isFlowLoaded()) {
                $wnd.Vaadin.connectionState.state = ConnectionState.CONNECTION_LOST;
            }
        });
    }
    /**
     * Calls the given endpoint method defined using the endpoint and method
     * parameters with the parameters given as params.
     * Asynchronously returns the parsed JSON response data.
     *
     * @param endpoint Endpoint name.
     * @param method Method name to call in the endpoint class.
     * @param params Optional parameters to pass to the method.
     * @param __init Optional parameters for the request
     * @returns {} Decoded JSON response data.
     */
    async call(endpoint, method, params, __init) {
        if (arguments.length < 2) {
            throw new TypeError(`2 arguments required, but got only ${arguments.length}`);
        }
        const csrfHeaders = getCsrfTokenHeadersForEndpointRequest(document);
        const headers = {
            Accept: 'application/json',
            'Content-Type': 'application/json',
            ...csrfHeaders,
        };
        // helper to keep the undefined value in object after JSON.stringify
        const nullForUndefined = (obj) => Object.keys(obj).reduce((_obj, property) => {
            if (_obj[property] === undefined) {
                _obj[property] = null;
            }
            return _obj;
        }, obj);
        const request = new Request(`${this.prefix}/${endpoint}/${method}`, {
            method: 'POST',
            headers,
            body: params !== undefined ? JSON.stringify(nullForUndefined(params)) : undefined,
        });
        // The middleware `context`, includes the call arguments and the request
        // constructed from them
        const initialContext = {
            endpoint,
            method,
            params,
            request,
        };
        // The internal middleware to assert and parse the response. The internal
        // response handling should come last after the other middlewares are done
        // with processing the response. That is why this middleware is first
        // in the final middlewares array.
        const responseHandlerMiddleware = async (context, next) => {
            const response = await next(context);
            await assertResponseIsOk(response);
            const text = await response.text();
            return JSON.parse(text, (_, value) => (value === null ? undefined : value));
        };
        // The actual fetch call itself is expressed as a middleware
        // chain item for our convenience. Always having an ending of the chain
        // this way makes the folding down below more concise.
        const fetchNext = async (context) => {
            $wnd.Vaadin.connectionState.loadingStarted();
            return fetch(context.request, { signal: __init === null || __init === void 0 ? void 0 : __init.signal })
                .then((response) => {
                $wnd.Vaadin.connectionState.loadingFinished();
                return response;
            })
                .catch((error) => {
                // don't bother about connections aborted by purpose
                if (error.name === 'AbortError') {
                    $wnd.Vaadin.connectionState.loadingFinished();
                }
                else {
                    $wnd.Vaadin.connectionState.loadingFailed();
                }
                return Promise.reject(error);
            });
        };
        // Assemble the final middlewares array from internal
        // and external middlewares
        const middlewares = [responseHandlerMiddleware].concat(this.middlewares);
        // Fold the final middlewares array into a single function
        const chain = middlewares.reduceRight((next, middleware) => {
            // Compose and return the new chain step, that takes the context and
            // invokes the current middleware with the context and the further chain
            // as the next argument
            return ((context) => {
                if (typeof middleware === 'function') {
                    return middleware(context, next);
                }
                return middleware.invoke(context, next);
            });
        }, 
        // Initialize reduceRight the accumulator with `fetchNext`
        fetchNext);
        // Invoke all the folded async middlewares and return
        return chain(initialContext);
    }
    /**
     * Subscribes to the given method defined using the endpoint and method
     * parameters with the parameters given as params. The method must return a
     * compatible type such as a Flux.
     * Returns a subscription that is used to fetch values as they become available.
     *
     * @param endpoint Endpoint name.
     * @param method Method name to call in the endpoint class.
     * @param params Optional parameters to pass to the method.
     * @returns {} A subscription used to handles values as they become available.
     */
    subscribe(endpoint, method, params) {
        return this.fluxConnection.subscribe(endpoint, method, params ? Object.values(params) : []);
    }
    /**
     * Gets a representation of the underlying persistent network connection used for subscribing to Flux type endpoint methods.
     */
    get fluxConnection() {
        if (!this._fluxConnection) {
            this._fluxConnection = new FluxConnection();
        }
        return this._fluxConnection;
    }
}
//# sourceMappingURL=Connect.js.map
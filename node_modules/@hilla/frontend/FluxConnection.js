import { atmosphere } from 'a-atmosphere-javascript';
import { getCsrfTokenHeadersForEndpointRequest } from './CsrfUtils';
export var State;
(function (State) {
    State["ACTIVE"] = "active";
    State["INACTIVE"] = "inactive";
})(State || (State = {}));
/**
 * A representation of the underlying persistent network connection used for subscribing to Flux type endpoint methods.
 */
export class FluxConnection extends EventTarget {
    constructor() {
        var _a, _b;
        super();
        Object.defineProperty(this, "nextId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "endpointInfos", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "onNextCallbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "onCompleteCallbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "onErrorCallbacks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "socket", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: State.INACTIVE
        });
        Object.defineProperty(this, "pendingMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        if (!((_b = (_a = window.Vaadin) === null || _a === void 0 ? void 0 : _a.featureFlags) === null || _b === void 0 ? void 0 : _b.hillaPush)) {
            // Remove when removing feature flag
            throw new Error(`Push support in Hilla is not enabled. Enable it in the debug window or by adding com.vaadin.experimental.hillaPush=true to vaadin-featureflags.properties`);
        }
        this.connectWebsocket();
    }
    connectWebsocket() {
        const extraHeaders = getCsrfTokenHeadersForEndpointRequest(document);
        const callback = {
            onMessage: (response) => {
                this.handleMessage(JSON.parse(response.responseBody));
            },
            onOpen: (_response) => {
                if (this.state === State.INACTIVE) {
                    this.state = State.ACTIVE;
                    this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: true } }));
                    this.sendPendingMessages();
                }
            },
            onReopen: (_response) => {
                if (this.state === State.INACTIVE) {
                    this.state = State.ACTIVE;
                    this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: true } }));
                    this.sendPendingMessages();
                }
            },
            onClose: (_response) => {
                // https://socket.io/docs/v4/client-api/#event-disconnect
                if (this.state === State.ACTIVE) {
                    this.state = State.INACTIVE;
                    this.dispatchEvent(new CustomEvent('state-changed', { detail: { active: false } }));
                }
            },
            onError: (response) => {
                // eslint-disable-next-line no-console
                console.error('error in push communication', response);
            },
        };
        this.socket = atmosphere.subscribe({
            url: '/HILLA/push',
            transport: 'websocket',
            fallbackTransport: 'long-polling',
            contentType: 'application/json; charset=UTF-8',
            reconnectInterval: 5000,
            timeout: -1,
            maxReconnectOnClose: 10000000,
            trackMessageLength: true,
            enableProtocol: true,
            headers: extraHeaders,
            ...callback,
        });
    }
    handleMessage(message) {
        const { id } = message;
        const endpointInfo = this.endpointInfos.get(id);
        if (message['@type'] === 'update') {
            const callback = this.onNextCallbacks.get(id);
            if (callback) {
                callback(message.item);
            }
        }
        else if (message['@type'] === 'complete') {
            const callback = this.onCompleteCallbacks.get(id);
            if (callback) {
                callback();
            }
            this.removeSubscription(id);
        }
        else if (message['@type'] === 'error') {
            const callback = this.onErrorCallbacks.get(id);
            if (callback) {
                callback();
            }
            this.removeSubscription(id);
            if (!callback) {
                throw new Error(`Error in ${endpointInfo}: ${message.message}`);
            }
        }
        else {
            throw new Error(`Unknown message from server: ${message}`);
        }
    }
    removeSubscription(id) {
        this.onNextCallbacks.delete(id);
        this.onCompleteCallbacks.delete(id);
        this.onErrorCallbacks.delete(id);
        this.endpointInfos.delete(id);
    }
    sendPendingMessages() {
        this.pendingMessages.forEach((msg) => this.send(msg));
        this.pendingMessages = [];
    }
    send(message) {
        if (this.state === State.INACTIVE) {
            this.pendingMessages.push(message);
        }
        else {
            this.socket.push(JSON.stringify(message));
        }
    }
    /**
     * Subscribes to the flux returned by the given endpoint name + method name using the given parameters.
     *
     * @param endpointName the endpoint to connect to
     * @param methodName the method in the endpoint to connect to
     * @param parameters the parameters to use
     * @returns a subscription
     */
    subscribe(endpointName, methodName, parameters) {
        const id = this.nextId.toString();
        this.nextId += 1;
        const params = parameters || [];
        const msg = { '@type': 'subscribe', id, endpointName, methodName, params };
        const endpointInfo = `${endpointName}.${methodName}(${JSON.stringify(params)})`;
        this.send(msg);
        this.endpointInfos.set(id, endpointInfo);
        const hillaSubscription = {
            onNext: (callback) => {
                this.onNextCallbacks.set(id, callback);
                return hillaSubscription;
            },
            onComplete: (callback) => {
                this.onCompleteCallbacks.set(id, callback);
                return hillaSubscription;
            },
            onError: (callback) => {
                this.onErrorCallbacks.set(id, callback);
                return hillaSubscription;
            },
            cancel: () => {
                if (!this.endpointInfos.has(id)) {
                    // Subscription already closed or canceled
                    return;
                }
                const closeMessage = { '@type': 'unsubscribe', id };
                this.send(closeMessage);
                this.removeSubscription(id);
            },
            context: (context) => {
                context.addController({
                    hostDisconnected: () => {
                        hillaSubscription.cancel();
                    },
                });
                return hillaSubscription;
            },
        };
        return hillaSubscription;
    }
}
//# sourceMappingURL=FluxConnection.js.map
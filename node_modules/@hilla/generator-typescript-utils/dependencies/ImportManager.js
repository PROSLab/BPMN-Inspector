import ts from 'typescript';
import createFullyUniqueIdentifier from '../createFullyUniqueIdentifier.js';
import StatementRecordManager from './StatementRecordManager.js';
import { createDependencyRecord } from './utils.js';
export class NamedImportManager extends StatementRecordManager {
    #collator;
    #map = new Map();
    constructor(collator) {
        super(collator);
        this.#collator = collator;
    }
    add(path, specifier, isType, uniqueId) {
        const record = createDependencyRecord(uniqueId ?? createFullyUniqueIdentifier(specifier), isType);
        if (this.#map.has(path)) {
            this.#map.get(path).set(specifier, record);
        }
        else {
            this.#map.set(path, new Map([[specifier, record]]));
        }
        return record.id;
    }
    clear() {
        this.#map.clear();
    }
    getIdentifier(path, specifier) {
        return this.#map.get(path)?.get(specifier)?.id;
    }
    *identifiers() {
        for (const [path, specifiers] of this.#map) {
            for (const [specifier, { id, isType }] of specifiers) {
                yield [path, specifier, id, isType];
            }
        }
    }
    isType(path, specifier) {
        return this.#map.get(path)?.get(specifier)?.isType;
    }
    paths() {
        return this.#map.keys();
    }
    *specifiers() {
        for (const [path, specifiers] of this.#map) {
            for (const specifier of specifiers.keys()) {
                yield [path, specifier];
            }
        }
    }
    *statementRecords() {
        for (const [path, specifiers] of this.#map) {
            const names = [...specifiers.keys()];
            names.sort(this.#collator.compare);
            yield [
                path,
                ts.factory.createImportDeclaration(undefined, undefined, ts.factory.createImportClause(false, undefined, ts.factory.createNamedImports(names.map((name) => {
                    const { id, isType } = specifiers.get(name);
                    return ts.factory.createImportSpecifier(isType, ts.factory.createIdentifier(name), id);
                }))), ts.factory.createStringLiteral(path)),
            ];
        }
    }
}
export class NamespaceImportManager extends StatementRecordManager {
    #map = new Map();
    add(path, name, uniqueId) {
        const id = uniqueId ?? createFullyUniqueIdentifier(name);
        this.#map.set(path, id);
        return id;
    }
    clear() {
        this.#map.clear();
    }
    getIdentifier(path) {
        return this.#map.get(path);
    }
    *identifiers() {
        for (const id of this.#map.values()) {
            yield id;
        }
    }
    paths() {
        return this.#map.keys();
    }
    *statementRecords() {
        for (const [path, id] of this.#map) {
            yield [
                path,
                ts.factory.createImportDeclaration(undefined, undefined, ts.factory.createImportClause(false, undefined, ts.factory.createNamespaceImport(id)), ts.factory.createStringLiteral(path)),
            ];
        }
    }
}
export class DefaultImportManager extends StatementRecordManager {
    #map = new Map();
    add(path, name, isType, uniqueId) {
        const id = uniqueId ?? createFullyUniqueIdentifier(name);
        this.#map.set(path, createDependencyRecord(id, isType));
        return id;
    }
    getIdentifier(path) {
        return this.#map.get(path)?.id;
    }
    clear() {
        this.#map.clear();
    }
    *identifiers() {
        for (const { id, isType } of this.#map.values()) {
            yield [id, isType];
        }
    }
    isType(path) {
        return this.#map.get(path)?.isType;
    }
    paths() {
        return this.#map.keys();
    }
    *statementRecords() {
        for (const [path, { id, isType }] of this.#map) {
            yield [
                path,
                ts.factory.createImportDeclaration(undefined, undefined, ts.factory.createImportClause(isType, id, undefined), ts.factory.createStringLiteral(path)),
            ];
        }
    }
}
export default class ImportManager {
    default;
    named;
    namespace;
    #collator;
    constructor(collator) {
        this.default = new DefaultImportManager(collator);
        this.named = new NamedImportManager(collator);
        this.namespace = new NamespaceImportManager(collator);
        this.#collator = collator;
    }
    toCode() {
        const records = [
            ...this.default.statementRecords(),
            ...this.named.statementRecords(),
            ...this.namespace.statementRecords(),
        ];
        records.sort(StatementRecordManager.createComparator(this.#collator));
        return records.map(([, statement]) => statement);
    }
    fromCode(source) {
        this.default.clear();
        this.named.clear();
        this.namespace.clear();
        const imports = source.statements.filter((statement) => ts.isImportDeclaration(statement));
        for (const { importClause, moduleSpecifier } of imports) {
            if (!importClause) {
                // eslint-disable-next-line no-continue
                continue;
            }
            const { name, namedBindings } = importClause;
            const path = moduleSpecifier.text;
            if (namedBindings) {
                if (ts.isNamespaceImport(namedBindings)) {
                    this.namespace.add(path, namedBindings.name.text, namedBindings.name);
                }
                else {
                    for (const { name: specifier, isTypeOnly } of namedBindings.elements) {
                        this.named.add(path, specifier.text, isTypeOnly, specifier);
                    }
                }
            }
            else if (name) {
                this.default.add(path, name.text, importClause.isTypeOnly, name);
            }
        }
    }
}
//# sourceMappingURL=ImportManager.js.map
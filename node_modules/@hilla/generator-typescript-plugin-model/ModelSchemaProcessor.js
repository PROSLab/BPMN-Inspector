/* eslint-disable symbol-description */
import { convertReferenceSchemaToPath, convertReferenceSchemaToSpecifier, decomposeSchema, isArraySchema, isBooleanSchema, isComposedSchema, isIntegerSchema, isMapSchema, isNullableSchema, isNumberSchema, isReferenceSchema, isStringSchema, } from '@hilla/generator-typescript-core/Schema.js';
import ts from 'typescript';
import { isAnnotatedSchema, isValidationConstrainedSchema, } from './Annotation.js';
import parseAnnotation from './parseAnnotation.js';
import { importBuiltInFormModel } from './utils.js';
function convertAttribute(attribute) {
    switch (typeof attribute) {
        case 'boolean':
            return attribute ? ts.factory.createTrue() : ts.factory.createFalse();
        case 'number':
            return ts.factory.createNumericLiteral(attribute);
        case 'string':
            return ts.factory.createStringLiteral(attribute);
        default:
            return ts.factory.createOmittedExpression();
    }
}
function convertNamedAttributes(attributes) {
    const attributeEntries = Object.entries(attributes);
    if (attributeEntries.length === 1 && attributeEntries[0][0] === 'value') {
        return convertAttribute(attributeEntries[0][1]);
    }
    return ts.factory.createObjectLiteralExpression(attributeEntries.map(([key, value]) => ts.factory.createPropertyAssignment(key, convertAttribute(value))), false);
}
const $dependencies = Symbol();
const $processArray = Symbol();
const $processRecord = Symbol();
const $processReference = Symbol();
const $processString = Symbol();
const $processNumber = Symbol();
const $processBoolean = Symbol();
const $processUnknown = Symbol();
const $originalSchema = Symbol();
const $schema = Symbol();
export class ModelSchemaPartProcessor {
    [$dependencies];
    [$originalSchema];
    [$schema];
    constructor(schema, dependencies) {
        this[$dependencies] = dependencies;
        this[$originalSchema] = schema;
        this[$schema] = isComposedSchema(schema) ? decomposeSchema(schema)[0] : schema;
    }
    process() {
        const schema = this[$schema];
        if (isReferenceSchema(schema)) {
            return this[$processReference](schema);
        }
        if (isArraySchema(schema)) {
            return this[$processArray](schema);
        }
        if (isMapSchema(schema)) {
            return this[$processRecord](schema);
        }
        if (isStringSchema(schema)) {
            return this[$processString](schema);
        }
        if (isNumberSchema(schema) || isIntegerSchema(schema)) {
            return this[$processNumber](schema);
        }
        if (isBooleanSchema(schema)) {
            return this[$processBoolean](schema);
        }
        return this[$processUnknown](schema);
    }
}
class ModelSchemaInternalTypeProcessor extends ModelSchemaPartProcessor {
    [$processArray](schema) {
        return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier('ReadonlyArray'), [
            new ModelSchemaInternalTypeProcessor(schema.items, this[$dependencies]).process(),
        ]);
    }
    [$processBoolean](_) {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);
    }
    [$processNumber](_) {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);
    }
    [$processRecord]({ additionalProperties: props }) {
        const valueType = typeof props === 'boolean'
            ? ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)
            : new ModelSchemaInternalTypeProcessor(props, this[$dependencies]).process();
        return ts.factory.createTypeReferenceNode(ts.factory.createIdentifier('Record'), [
            ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
            valueType,
        ]);
    }
    [$processReference](schema) {
        const { paths, imports } = this[$dependencies];
        const typeName = convertReferenceSchemaToSpecifier(schema);
        const typePath = paths.createRelativePath(convertReferenceSchemaToPath(schema));
        return ts.factory.createTypeReferenceNode(imports.default.getIdentifier(typePath) ?? imports.default.add(typePath, typeName, true));
    }
    [$processString](_) {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
    }
    [$processUnknown](_) {
        return ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);
    }
}
class ModelSchemaIdentifierProcessor extends ModelSchemaPartProcessor {
    [$processArray](_) {
        return importBuiltInFormModel('ArrayModel', this[$dependencies]);
    }
    [$processBoolean](_) {
        return importBuiltInFormModel('BooleanModel', this[$dependencies]);
    }
    [$processNumber](_) {
        return importBuiltInFormModel('NumberModel', this[$dependencies]);
    }
    [$processRecord](_) {
        return importBuiltInFormModel('ObjectModel', this[$dependencies]);
    }
    [$processReference](schema) {
        const { paths, imports } = this[$dependencies];
        const name = `${convertReferenceSchemaToSpecifier(schema)}Model`;
        const path = paths.createRelativePath(`${convertReferenceSchemaToPath(schema)}Model`);
        return imports.default.getIdentifier(path) ?? imports.default.add(path, name);
    }
    [$processString](_) {
        return importBuiltInFormModel('StringModel', this[$dependencies]);
    }
    [$processUnknown](_) {
        return importBuiltInFormModel('ObjectModel', this[$dependencies]);
    }
}
export class ModelSchemaTypeProcessor extends ModelSchemaPartProcessor {
    #id;
    constructor(schema, dependencies) {
        super(schema, dependencies);
        this.#id = new ModelSchemaIdentifierProcessor(schema, dependencies);
    }
    [$processArray](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processArray](schema), [
            new ModelSchemaInternalTypeProcessor(schema.items, this[$dependencies]).process(),
            new ModelSchemaTypeProcessor(schema.items, this[$dependencies]).process(),
        ]);
    }
    [$processBoolean](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processBoolean](schema));
    }
    [$processNumber](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processNumber](schema));
    }
    [$processRecord](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processRecord](schema), [
            new ModelSchemaInternalTypeProcessor(schema, this[$dependencies]).process(),
        ]);
    }
    [$processReference](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processReference](schema));
    }
    [$processString](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processString](schema));
    }
    [$processUnknown](schema) {
        return ts.factory.createTypeReferenceNode(this.#id[$processUnknown](schema), [
            ts.factory.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword),
        ]);
    }
}
export class ModelSchemaExpressionProcessor extends ModelSchemaPartProcessor {
    #checkOptional;
    constructor(schema, dependencies, checkOptional = isNullableSchema) {
        super(schema, dependencies);
        this.#checkOptional = checkOptional;
    }
    process() {
        const schema = this[$schema];
        let result = super.process();
        if (isAnnotatedSchema(schema)) {
            result = [...result, ...this.#getValidatorsFromAnnotations(schema)];
        }
        if (isValidationConstrainedSchema(schema)) {
            result = [...result, ...this.#getValidatorsFromValidationConstraints(schema)];
        }
        return [this.#checkOptional(this[$originalSchema]) ? ts.factory.createTrue() : ts.factory.createFalse(), ...result];
    }
    [$processArray](schema) {
        return [
            new ModelSchemaIdentifierProcessor(schema.items, this[$dependencies]).process(),
            ts.factory.createArrayLiteralExpression(new ModelSchemaExpressionProcessor(schema.items, this[$dependencies]).process()),
        ];
    }
    [$processBoolean](_) {
        return [];
    }
    [$processNumber](_) {
        return [];
    }
    [$processRecord](_) {
        return [];
    }
    [$processReference](_) {
        return [];
    }
    [$processString](_) {
        return [];
    }
    [$processUnknown](_) {
        return [];
    }
    #getValidator = (annotation) => ts.factory.createNewExpression(importBuiltInFormModel(annotation.simpleName, this[$dependencies]), undefined, annotation.attributes !== undefined ? [convertNamedAttributes(annotation.attributes)] : []);
    #getValidatorsFromAnnotations(schema) {
        return schema['x-annotations'].map(parseAnnotation).map(this.#getValidator);
    }
    #getValidatorsFromValidationConstraints(schema) {
        return schema['x-validation-constraints'].map(this.#getValidator);
    }
}
//# sourceMappingURL=ModelSchemaProcessor.js.map
import { convertFullyQualifiedNameToRelativePath, simplifyFullyQualifiedName } from './utils.js';
export function isReferenceSchema(schema) {
    return '$ref' in schema;
}
export function isAnyOfRuleComposedSchema(schema) {
    return 'anyOf' in schema;
}
export function isAllOfRuleComposedSchema(schema) {
    return 'allOf' in schema;
}
export function isOneOfRuleComposedSchema(schema) {
    return 'oneOf' in schema;
}
export function isNotRuleComposedSchema(schema) {
    return 'not' in schema;
}
export function isComposedSchema(schema) {
    return (isAnyOfRuleComposedSchema(schema) ||
        isAllOfRuleComposedSchema(schema) ||
        isOneOfRuleComposedSchema(schema) ||
        isNotRuleComposedSchema(schema));
}
export function isNonComposedSchema(schema) {
    return !isComposedSchema(schema);
}
export function isNonComposedRegularSchema(schema) {
    return isNonComposedSchema(schema) && !isReferenceSchema(schema);
}
export function isNullableSchema(schema) {
    return !isReferenceSchema(schema) && !!schema.nullable;
}
export function decomposeSchema(schema) {
    if (isAnyOfRuleComposedSchema(schema)) {
        return schema.anyOf;
    }
    if (isAllOfRuleComposedSchema(schema)) {
        return schema.allOf;
    }
    if (isOneOfRuleComposedSchema(schema)) {
        return schema.oneOf;
    }
    return [schema.not];
}
export function isArraySchema(schema) {
    return isNonComposedRegularSchema(schema) && schema.type === 'array';
}
export function isBooleanSchema(schema) {
    return isNonComposedRegularSchema(schema) && schema.type === 'boolean';
}
export function isIntegerSchema(schema) {
    return isNonComposedRegularSchema(schema) && schema.type === 'integer';
}
export function isNumberSchema(schema) {
    return isNonComposedRegularSchema(schema) && schema.type === 'number';
}
export function isObjectSchema(schema) {
    return isNonComposedRegularSchema(schema) && schema.type === 'object';
}
export function isStringSchema(schema) {
    return isNonComposedRegularSchema(schema) && schema.type === 'string';
}
export function isEnumSchema(schema) {
    return isStringSchema(schema) && !!schema.enum;
}
export function isEmptyObject(schema) {
    return isObjectSchema(schema) && !schema.properties;
}
export function isMapSchema(schema) {
    return isEmptyObject(schema) && !!schema.additionalProperties;
}
export function convertReferenceSchemaToSpecifier({ $ref }) {
    return simplifyFullyQualifiedName($ref);
}
const COMPONENTS_SCHEMAS_REF_LENGTH = '#/components/schemas/'.length;
export function convertReferenceSchemaToPath({ $ref }) {
    return convertFullyQualifiedNameToRelativePath($ref.substring(COMPONENTS_SCHEMAS_REF_LENGTH));
}
export function resolveReference(schemas, { $ref }) {
    if (schemas) {
        for (const [name, schema] of Object.entries(schemas)) {
            if ($ref.includes(name)) {
                return schema;
            }
        }
    }
    return undefined;
}
//# sourceMappingURL=Schema.js.map
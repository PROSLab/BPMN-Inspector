import {
  __reExport
} from "./chunk-BQOD6VY2.js";

// node_modules/@hilla/frontend/CookieUtils.js
function getCookie(name) {
  const prefix = `${name}=`;
  return document.cookie.split(/;[ ]?/).filter((cookie) => cookie.startsWith(prefix)).map((cookie) => cookie.slice(prefix.length))[0];
}
function setCookie(name, value, options) {
  const _options = {
    [name]: value,
    ...options
  };
  document.cookie = Object.entries(_options).map(([key, val]) => `${key}=${val}`).join("; ");
}
function deleteCookie(name, options) {
  setCookie(name, "", { Expires: "Thu, 01 Jan 1970 00:00:00 GMT", ...options });
}
function removeTrailingSlashFromPath(path) {
  if (path.length > 1 && path.substr(-1, 1) === "/") {
    path = path.substr(0, path.length - 1);
  }
  return path;
}

// node_modules/@hilla/frontend/CsrfUtils.js
var VAADIN_CSRF_HEADER = "X-CSRF-Token";
var VAADIN_CSRF_COOKIE_NAME = "csrfToken";
var SPRING_CSRF_COOKIE_NAME = "XSRF-TOKEN";
function extractContentFromMetaTag(element) {
  if (element) {
    const value = element.content;
    if (value && value.toLowerCase() !== "undefined") {
      return value;
    }
  }
  return void 0;
}
function getSpringCsrfHeaderFromMetaTag(doc) {
  const csrfHeader = doc.head.querySelector('meta[name="_csrf_header"]');
  return extractContentFromMetaTag(csrfHeader);
}
function getSpringCsrfTokenFromMetaTag(doc) {
  const csrfToken = doc.head.querySelector('meta[name="_csrf"]');
  return extractContentFromMetaTag(csrfToken);
}
function getSpringCsrfInfo(doc) {
  const csrfHeader = getSpringCsrfHeaderFromMetaTag(doc);
  let csrf = getCookie(SPRING_CSRF_COOKIE_NAME);
  if (!csrf || csrf.length === 0) {
    csrf = getSpringCsrfTokenFromMetaTag(doc);
  }
  const headers = {};
  if (csrf && csrfHeader) {
    headers._csrf = csrf;
    headers._csrf_header = csrfHeader;
  }
  return headers;
}
function getSpringCsrfTokenHeadersForAuthRequest(doc) {
  const csrfInfo = getSpringCsrfInfo(doc);
  const headers = {};
  if (csrfInfo._csrf && csrfInfo._csrf_header) {
    headers[csrfInfo._csrf_header] = csrfInfo._csrf;
  }
  return headers;
}
function getCsrfTokenHeadersForEndpointRequest(doc) {
  const headers = {};
  const csrfInfo = getSpringCsrfInfo(doc);
  if (csrfInfo._csrf && csrfInfo._csrf_header) {
    headers[csrfInfo._csrf_header] = csrfInfo._csrf;
  } else {
    headers[VAADIN_CSRF_HEADER] = getCookie(VAADIN_CSRF_COOKIE_NAME) || "";
  }
  return headers;
}

// node_modules/@hilla/frontend/Authentication.js
var jwtCookieName = "jwt.headerAndPayload";
function getSpringCsrfTokenFromResponseBody(body) {
  const doc = new DOMParser().parseFromString(body, "text/html");
  return getSpringCsrfInfo(doc);
}
function clearSpringCsrfMetaTags() {
  Array.from(document.head.querySelectorAll('meta[name="_csrf"], meta[name="_csrf_header"]')).forEach((el) => el.remove());
}
function updateSpringCsrfMetaTags(springCsrfInfo) {
  clearSpringCsrfMetaTags();
  const headerNameMeta = document.createElement("meta");
  headerNameMeta.name = "_csrf_header";
  headerNameMeta.content = springCsrfInfo._csrf_header;
  document.head.appendChild(headerNameMeta);
  const tokenMeta = document.createElement("meta");
  tokenMeta.name = "_csrf";
  tokenMeta.content = springCsrfInfo._csrf;
  document.head.appendChild(tokenMeta);
}
var getVaadinCsrfTokenFromResponseBody = (body) => {
  const match = body.match(/window\.Vaadin = \{TypeScript: \{"csrfToken":"([0-9a-zA-Z\\-]{36})"}};/i);
  return match ? match[1] : void 0;
};
async function updateCsrfTokensBasedOnResponse(response) {
  const responseText = await response.text();
  const token = getVaadinCsrfTokenFromResponseBody(responseText);
  const springCsrfTokenInfo = getSpringCsrfTokenFromResponseBody(responseText);
  updateSpringCsrfMetaTags(springCsrfTokenInfo);
  return token;
}
async function doLogout(logoutUrl, headers) {
  const response = await fetch(logoutUrl, { method: "POST", headers });
  if (!response.ok) {
    throw new Error(`failed to logout with response ${response.status}`);
  }
  await updateCsrfTokensBasedOnResponse(response);
}
function deleteJWTCookie() {
  const cookiePath = removeTrailingSlashFromPath(new URL(document.baseURI).pathname);
  deleteCookie(jwtCookieName, { Path: cookiePath });
}
async function login(username, password, options) {
  try {
    const data = new FormData();
    data.append("username", username);
    data.append("password", password);
    const loginProcessingUrl = options && options.loginProcessingUrl ? options.loginProcessingUrl : "login";
    const headers = getSpringCsrfTokenHeadersForAuthRequest(document);
    headers.source = "typescript";
    const response = await fetch(loginProcessingUrl, {
      method: "POST",
      body: data,
      headers
    });
    const result = response.headers.get("Result");
    const savedUrl = response.headers.get("Saved-url") || void 0;
    const defaultUrl = response.headers.get("Default-url") || void 0;
    const loginSuccessful = response.ok && result === "success";
    if (loginSuccessful) {
      const vaadinCsrfToken = response.headers.get("Vaadin-CSRF") || void 0;
      const springCsrfHeader = response.headers.get("Spring-CSRF-header") || void 0;
      const springCsrfToken = response.headers.get("Spring-CSRF-token") || void 0;
      if (springCsrfHeader && springCsrfToken) {
        const springCsrfTokenInfo = {};
        springCsrfTokenInfo._csrf = springCsrfToken;
        springCsrfTokenInfo._csrf_header = springCsrfHeader;
        updateSpringCsrfMetaTags(springCsrfTokenInfo);
      }
      return {
        error: false,
        token: vaadinCsrfToken,
        redirectUrl: savedUrl,
        defaultUrl
      };
    }
    return {
      error: true,
      errorTitle: "Incorrect username or password.",
      errorMessage: "Check that you have entered the correct username and password and try again."
    };
  } catch (e) {
    return {
      error: true,
      errorTitle: e.name,
      errorMessage: e.message
    };
  }
}
async function logout(options) {
  const logoutUrl = options && options.logoutUrl ? options.logoutUrl : "logout";
  try {
    const headers = getSpringCsrfTokenHeadersForAuthRequest(document);
    await doLogout(logoutUrl, headers);
  } catch {
    try {
      const response = await fetch("?nocache");
      const responseText = await response.text();
      const doc = new DOMParser().parseFromString(responseText, "text/html");
      const headers = getSpringCsrfTokenHeadersForAuthRequest(doc);
      await doLogout(logoutUrl, headers);
    } catch (error) {
      clearSpringCsrfMetaTags();
      throw error;
    }
  } finally {
    deleteJWTCookie();
  }
}
var InvalidSessionMiddleware = class {
  constructor(onInvalidSessionCallback) {
    Object.defineProperty(this, "onInvalidSessionCallback", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.onInvalidSessionCallback = onInvalidSessionCallback;
  }
  async invoke(context, next) {
    const clonedContext = { ...context };
    clonedContext.request = context.request.clone();
    const response = await next(context);
    if (response.status === 401) {
      const loginResult = await this.onInvalidSessionCallback();
      if (loginResult.token) {
        clonedContext.request.headers.set(VAADIN_CSRF_HEADER, loginResult.token);
        return next(clonedContext);
      }
    }
    return response;
  }
};

// node_modules/@vaadin/common-frontend/ConnectionState.js
var _a;
var ConnectionState;
(function(ConnectionState2) {
  ConnectionState2["CONNECTED"] = "connected";
  ConnectionState2["LOADING"] = "loading";
  ConnectionState2["RECONNECTING"] = "reconnecting";
  ConnectionState2["CONNECTION_LOST"] = "connection-lost";
})(ConnectionState || (ConnectionState = {}));
var ConnectionStateStore = class {
  constructor(initialState) {
    this.stateChangeListeners = /* @__PURE__ */ new Set();
    this.loadingCount = 0;
    this.connectionState = initialState;
    this.serviceWorkerMessageListener = this.serviceWorkerMessageListener.bind(this);
    if (navigator.serviceWorker) {
      navigator.serviceWorker.addEventListener("message", this.serviceWorkerMessageListener);
      navigator.serviceWorker.ready.then((registration) => {
        var _a2;
        (_a2 = registration === null || registration === void 0 ? void 0 : registration.active) === null || _a2 === void 0 ? void 0 : _a2.postMessage({
          method: "Vaadin.ServiceWorker.isConnectionLost",
          id: "Vaadin.ServiceWorker.isConnectionLost"
        });
      });
    }
  }
  addStateChangeListener(listener) {
    this.stateChangeListeners.add(listener);
  }
  removeStateChangeListener(listener) {
    this.stateChangeListeners.delete(listener);
  }
  loadingStarted() {
    this.state = ConnectionState.LOADING;
    this.loadingCount += 1;
  }
  loadingFinished() {
    this.decreaseLoadingCount(ConnectionState.CONNECTED);
  }
  loadingFailed() {
    this.decreaseLoadingCount(ConnectionState.CONNECTION_LOST);
  }
  decreaseLoadingCount(finalState) {
    if (this.loadingCount > 0) {
      this.loadingCount -= 1;
      if (this.loadingCount === 0) {
        this.state = finalState;
      }
    }
  }
  get state() {
    return this.connectionState;
  }
  set state(newState) {
    if (newState !== this.connectionState) {
      const prevState = this.connectionState;
      this.connectionState = newState;
      this.loadingCount = 0;
      for (const listener of this.stateChangeListeners) {
        listener(prevState, this.connectionState);
      }
    }
  }
  get online() {
    return this.connectionState === ConnectionState.CONNECTED || this.connectionState === ConnectionState.LOADING;
  }
  get offline() {
    return !this.online;
  }
  serviceWorkerMessageListener(event) {
    if (typeof event.data === "object" && event.data.id === "Vaadin.ServiceWorker.isConnectionLost") {
      if (event.data.result === true) {
        this.state = ConnectionState.CONNECTION_LOST;
      }
      navigator.serviceWorker.removeEventListener("message", this.serviceWorkerMessageListener);
    }
  }
};
var $wnd = window;
if (!((_a = $wnd.Vaadin) === null || _a === void 0 ? void 0 : _a.connectionState)) {
  $wnd.Vaadin = $wnd.Vaadin || {};
  $wnd.Vaadin.connectionState = new ConnectionStateStore(navigator.onLine ? ConnectionState.CONNECTED : ConnectionState.CONNECTION_LOST);
}

// node_modules/tslib/tslib.es6.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

// external:lit
var lit_exports = {};
__reExport(lit_exports, lit_star);
import * as lit_star from "lit";

// node_modules/@vaadin/common-frontend/ConnectionIndicator.js
import { property } from "lit/decorators.js";
import { classMap } from "lit/directives/class-map.js";
var DEFAULT_STYLE_ID = "css-loading-indicator";
var LoadingBarState;
(function(LoadingBarState2) {
  LoadingBarState2["IDLE"] = "";
  LoadingBarState2["FIRST"] = "first";
  LoadingBarState2["SECOND"] = "second";
  LoadingBarState2["THIRD"] = "third";
})(LoadingBarState || (LoadingBarState = {}));
var ConnectionIndicator = class extends lit_exports.LitElement {
  constructor() {
    super();
    this.firstDelay = 300;
    this.secondDelay = 1500;
    this.thirdDelay = 5e3;
    this.expandedDuration = 2e3;
    this.onlineText = "Online";
    this.offlineText = "Connection lost";
    this.reconnectingText = "Connection lost, trying to reconnect...";
    this.offline = false;
    this.reconnecting = false;
    this.expanded = false;
    this.loading = false;
    this.loadingBarState = LoadingBarState.IDLE;
    this.applyDefaultThemeState = true;
    this.firstTimeout = 0;
    this.secondTimeout = 0;
    this.thirdTimeout = 0;
    this.expandedTimeout = 0;
    this.lastMessageState = ConnectionState.CONNECTED;
    this.connectionStateListener = () => {
      this.expanded = this.updateConnectionState();
      this.expandedTimeout = this.timeoutFor(this.expandedTimeout, this.expanded, () => {
        this.expanded = false;
      }, this.expandedDuration);
    };
  }
  static create() {
    var _a2, _b;
    const $wnd5 = window;
    if (!((_a2 = $wnd5.Vaadin) === null || _a2 === void 0 ? void 0 : _a2.connectionIndicator)) {
      $wnd5.Vaadin = $wnd5.Vaadin || {};
      $wnd5.Vaadin.connectionIndicator = document.createElement("vaadin-connection-indicator");
      document.body.appendChild($wnd5.Vaadin.connectionIndicator);
    }
    return (_b = $wnd5.Vaadin) === null || _b === void 0 ? void 0 : _b.connectionIndicator;
  }
  render() {
    return lit_exports.html`
      <div class="v-loading-indicator ${this.loadingBarState}" style=${this.getLoadingBarStyle()}></div>

      <div
        class="v-status-message ${classMap({
      active: this.reconnecting
    })}"
      >
        <span class="text"> ${this.renderMessage()} </span>
      </div>
    `;
  }
  connectedCallback() {
    var _a2;
    super.connectedCallback();
    const $wnd5 = window;
    if ((_a2 = $wnd5.Vaadin) === null || _a2 === void 0 ? void 0 : _a2.connectionState) {
      this.connectionStateStore = $wnd5.Vaadin.connectionState;
      this.connectionStateStore.addStateChangeListener(this.connectionStateListener);
      this.updateConnectionState();
    }
    this.updateTheme();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this.connectionStateStore) {
      this.connectionStateStore.removeStateChangeListener(this.connectionStateListener);
    }
    this.updateTheme();
  }
  get applyDefaultTheme() {
    return this.applyDefaultThemeState;
  }
  set applyDefaultTheme(applyDefaultTheme) {
    if (applyDefaultTheme !== this.applyDefaultThemeState) {
      this.applyDefaultThemeState = applyDefaultTheme;
      this.updateTheme();
    }
  }
  createRenderRoot() {
    return this;
  }
  updateConnectionState() {
    var _a2;
    const state = (_a2 = this.connectionStateStore) === null || _a2 === void 0 ? void 0 : _a2.state;
    this.offline = state === ConnectionState.CONNECTION_LOST;
    this.reconnecting = state === ConnectionState.RECONNECTING;
    this.updateLoading(state === ConnectionState.LOADING);
    if (this.loading) {
      return false;
    }
    if (state !== this.lastMessageState) {
      this.lastMessageState = state;
      return true;
    }
    return false;
  }
  updateLoading(loading) {
    this.loading = loading;
    this.loadingBarState = LoadingBarState.IDLE;
    this.firstTimeout = this.timeoutFor(this.firstTimeout, loading, () => {
      this.loadingBarState = LoadingBarState.FIRST;
    }, this.firstDelay);
    this.secondTimeout = this.timeoutFor(this.secondTimeout, loading, () => {
      this.loadingBarState = LoadingBarState.SECOND;
    }, this.secondDelay);
    this.thirdTimeout = this.timeoutFor(this.thirdTimeout, loading, () => {
      this.loadingBarState = LoadingBarState.THIRD;
    }, this.thirdDelay);
  }
  renderMessage() {
    if (this.reconnecting) {
      return this.reconnectingText;
    }
    if (this.offline) {
      return this.offlineText;
    }
    return this.onlineText;
  }
  updateTheme() {
    if (this.applyDefaultThemeState && this.isConnected) {
      if (!document.getElementById(DEFAULT_STYLE_ID)) {
        const style = document.createElement("style");
        style.id = DEFAULT_STYLE_ID;
        style.textContent = this.getDefaultStyle();
        document.head.appendChild(style);
      }
    } else {
      const style = document.getElementById(DEFAULT_STYLE_ID);
      if (style) {
        document.head.removeChild(style);
      }
    }
  }
  getDefaultStyle() {
    return `
      @keyframes v-progress-start {
        0% {
          width: 0%;
        }
        100% {
          width: 50%;
        }
      }
      @keyframes v-progress-delay {
        0% {
          width: 50%;
        }
        100% {
          width: 90%;
        }
      }
      @keyframes v-progress-wait {
        0% {
          width: 90%;
          height: 4px;
        }
        3% {
          width: 91%;
          height: 7px;
        }
        100% {
          width: 96%;
          height: 7px;
        }
      }
      @keyframes v-progress-wait-pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.1;
        }
        100% {
          opacity: 1;
        }
      }
      .v-loading-indicator,
      .v-status-message {
        position: fixed;
        z-index: 251;
        left: 0;
        right: auto;
        top: 0;
        background-color: var(--lumo-primary-color, var(--material-primary-color, blue));
        transition: none;
      }
      .v-loading-indicator {
        width: 50%;
        height: 4px;
        opacity: 1;
        pointer-events: none;
        animation: v-progress-start 1000ms 200ms both;
      }
      .v-loading-indicator[style*='none'] {
        display: block !important;
        width: 100%;
        opacity: 0;
        animation: none;
        transition: opacity 500ms 300ms, width 300ms;
      }
      .v-loading-indicator.second {
        width: 90%;
        animation: v-progress-delay 3.8s forwards;
      }
      .v-loading-indicator.third {
        width: 96%;
        animation: v-progress-wait 5s forwards, v-progress-wait-pulse 1s 4s infinite backwards;
      }

      vaadin-connection-indicator[offline] .v-loading-indicator,
      vaadin-connection-indicator[reconnecting] .v-loading-indicator {
        display: none;
      }

      .v-status-message {
        opacity: 0;
        width: 100%;
        max-height: var(--status-height-collapsed, 8px);
        overflow: hidden;
        background-color: var(--status-bg-color-online, var(--lumo-primary-color, var(--material-primary-color, blue)));
        color: var(
          --status-text-color-online,
          var(--lumo-primary-contrast-color, var(--material-primary-contrast-color, #fff))
        );
        font-size: 0.75rem;
        font-weight: 600;
        line-height: 1;
        transition: all 0.5s;
        padding: 0 0.5em;
      }

      vaadin-connection-indicator[offline] .v-status-message,
      vaadin-connection-indicator[reconnecting] .v-status-message {
        opacity: 1;
        background-color: var(--status-bg-color-offline, var(--lumo-shade, #333));
        color: var(
          --status-text-color-offline,
          var(--lumo-primary-contrast-color, var(--material-primary-contrast-color, #fff))
        );
        background-image: repeating-linear-gradient(
          45deg,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0) 10px,
          rgba(255, 255, 255, 0.1) 10px,
          rgba(255, 255, 255, 0.1) 20px
        );
      }

      vaadin-connection-indicator[reconnecting] .v-status-message {
        animation: show-reconnecting-status 2s;
      }

      vaadin-connection-indicator[offline] .v-status-message:hover,
      vaadin-connection-indicator[reconnecting] .v-status-message:hover,
      vaadin-connection-indicator[expanded] .v-status-message {
        max-height: var(--status-height, 1.75rem);
      }

      vaadin-connection-indicator[expanded] .v-status-message {
        opacity: 1;
      }

      .v-status-message span {
        display: flex;
        align-items: center;
        justify-content: center;
        height: var(--status-height, 1.75rem);
      }

      vaadin-connection-indicator[reconnecting] .v-status-message span::before {
        content: '';
        width: 1em;
        height: 1em;
        border-top: 2px solid
          var(--status-spinner-color, var(--lumo-primary-color, var(--material-primary-color, blue)));
        border-left: 2px solid
          var(--status-spinner-color, var(--lumo-primary-color, var(--material-primary-color, blue)));
        border-right: 2px solid transparent;
        border-bottom: 2px solid transparent;
        border-radius: 50%;
        box-sizing: border-box;
        animation: v-spin 0.4s linear infinite;
        margin: 0 0.5em;
      }

      @keyframes v-spin {
        100% {
          transform: rotate(360deg);
        }
      }
    `;
  }
  getLoadingBarStyle() {
    switch (this.loadingBarState) {
      case LoadingBarState.IDLE:
        return "display: none";
      case LoadingBarState.FIRST:
      case LoadingBarState.SECOND:
      case LoadingBarState.THIRD:
        return "display: block";
      default:
        return "";
    }
  }
  timeoutFor(timeoutId, enabled, handler, delay) {
    if (timeoutId !== 0) {
      window.clearTimeout(timeoutId);
    }
    return enabled ? window.setTimeout(handler, delay) : 0;
  }
  static get instance() {
    return ConnectionIndicator.create();
  }
};
__decorate([
  property({ type: Number })
], ConnectionIndicator.prototype, "firstDelay", void 0);
__decorate([
  property({ type: Number })
], ConnectionIndicator.prototype, "secondDelay", void 0);
__decorate([
  property({ type: Number })
], ConnectionIndicator.prototype, "thirdDelay", void 0);
__decorate([
  property({ type: Number })
], ConnectionIndicator.prototype, "expandedDuration", void 0);
__decorate([
  property({ type: String })
], ConnectionIndicator.prototype, "onlineText", void 0);
__decorate([
  property({ type: String })
], ConnectionIndicator.prototype, "offlineText", void 0);
__decorate([
  property({ type: String })
], ConnectionIndicator.prototype, "reconnectingText", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ConnectionIndicator.prototype, "offline", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ConnectionIndicator.prototype, "reconnecting", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ConnectionIndicator.prototype, "expanded", void 0);
__decorate([
  property({ type: Boolean, reflect: true })
], ConnectionIndicator.prototype, "loading", void 0);
__decorate([
  property({ type: String })
], ConnectionIndicator.prototype, "loadingBarState", void 0);
__decorate([
  property({ type: Boolean })
], ConnectionIndicator.prototype, "applyDefaultTheme", null);
if (customElements.get("vaadin-connection-indicator") === void 0) {
  customElements.define("vaadin-connection-indicator", ConnectionIndicator);
}
var connectionIndicator = ConnectionIndicator.instance;

// node_modules/@vaadin/common-frontend/index.js
var $wnd2 = window;
$wnd2.Vaadin = $wnd2.Vaadin || {};
$wnd2.Vaadin.registrations = $wnd2.Vaadin.registrations || [];
$wnd2.Vaadin.registrations.push({
  is: "@vaadin/common-frontend",
  version: "0.0.17"
});

// node_modules/a-atmosphere-javascript/atmosphere.js
var guid;
var offline = false;
var requests = [];
var callbacks = [];
var uuid = 0;
var atmosphere = {
  version: "3.1.4-javascript",
  onError: function(response) {
  },
  onClose: function(response) {
  },
  onOpen: function(response) {
  },
  onReopen: function(response) {
  },
  onMessage: function(response) {
  },
  onReconnect: function(request, response) {
  },
  onMessagePublished: function(response) {
  },
  onTransportFailure: function(errorMessage, _request) {
  },
  onLocalMessage: function(response) {
  },
  onFailureToReconnect: function(request, response) {
  },
  onClientTimeout: function(request) {
  },
  onOpenAfterResume: function(request) {
  },
  WebsocketApiAdapter: function(request) {
    var _socket, _adapter;
    request.onMessage = function(e) {
      _adapter.onmessage({ data: e.responseBody });
    };
    request.onMessagePublished = function(e) {
      _adapter.onmessage({ data: e.responseBody });
    };
    request.onOpen = function(e) {
      _adapter.onopen(e);
    };
    _adapter = {
      close: function() {
        _socket.close();
      },
      send: function(data) {
        _socket.push(data);
      },
      onmessage: function(e) {
      },
      onopen: function(e) {
      },
      onclose: function(e) {
      },
      onerror: function(e) {
      }
    };
    _socket = new atmosphere.subscribe(request);
    return _adapter;
  },
  AtmosphereRequest: function(options) {
    var _request = {
      timeout: 3e5,
      method: "GET",
      headers: {},
      contentType: "",
      callback: null,
      url: "",
      data: "",
      suspend: true,
      maxRequest: -1,
      reconnect: true,
      maxStreamingLength: 1e7,
      lastIndex: 0,
      logLevel: "info",
      requestCount: 0,
      fallbackMethod: "GET",
      fallbackTransport: "streaming",
      transport: "long-polling",
      webSocketImpl: null,
      webSocketBinaryType: null,
      dispatchUrl: null,
      webSocketPathDelimiter: "@@",
      enableXDR: false,
      rewriteURL: false,
      attachHeadersAsQueryString: true,
      executeCallbackBeforeReconnect: false,
      readyState: 0,
      withCredentials: false,
      trackMessageLength: false,
      messageDelimiter: "|",
      connectTimeout: -1,
      reconnectInterval: 0,
      dropHeaders: true,
      uuid: 0,
      shared: false,
      readResponsesHeaders: false,
      maxReconnectOnClose: 5,
      enableProtocol: true,
      disableDisconnect: false,
      pollingInterval: 0,
      heartbeat: {
        client: null,
        server: null
      },
      ackInterval: 0,
      reconnectOnServerError: true,
      handleOnlineOffline: true,
      maxWebsocketErrorRetries: 1,
      curWebsocketErrorRetries: 0,
      unloadBackwardCompat: !navigator.sendBeacon,
      onError: function(response) {
      },
      onClose: function(response) {
      },
      onOpen: function(response) {
      },
      onMessage: function(response) {
      },
      onReopen: function(request, response) {
      },
      onReconnect: function(request, response) {
      },
      onMessagePublished: function(response) {
      },
      onTransportFailure: function(reason, request) {
      },
      onLocalMessage: function(request) {
      },
      onFailureToReconnect: function(request, response) {
      },
      onClientTimeout: function(request) {
      },
      onOpenAfterResume: function(request) {
      }
    };
    var _response = {
      status: 200,
      reasonPhrase: "OK",
      responseBody: "",
      messages: [],
      headers: [],
      state: "messageReceived",
      transport: "polling",
      error: null,
      request: null,
      partialMessage: "",
      errorHandled: false,
      closedByClientTimeout: false,
      ffTryingReconnect: false
    };
    var _websocket = null;
    var _sse = null;
    var _activeRequest = null;
    var _ieStream = null;
    var _jqxhr = null;
    var _subscribed = true;
    var _requestCount = 0;
    var _heartbeatInterval = 0;
    var _heartbeatPadding = "X";
    var _abortingConnection = false;
    var _localSocketF = null;
    var _storageService;
    var _localStorageService = null;
    var guid2 = atmosphere.util.now();
    var _traceTimer;
    var _sharingKey;
    var _beforeUnloadState = false;
    var _beforeUnloadTimeoutId;
    _subscribe(options);
    function _init() {
      _subscribed = true;
      _abortingConnection = false;
      _requestCount = 0;
      _websocket = null;
      _sse = null;
      _activeRequest = null;
      _ieStream = null;
    }
    function _reinit() {
      _clearState();
      _init();
    }
    function _canLog(level) {
      if (level == "debug") {
        return _request.logLevel === "debug";
      } else if (level == "info") {
        return _request.logLevel === "info" || _request.logLevel === "debug";
      } else if (level == "warn") {
        return _request.logLevel === "warn" || _request.logLevel === "info" || _request.logLevel === "debug";
      } else if (level == "error") {
        return _request.logLevel === "error" || _request.logLevel === "warn" || _request.logLevel === "info" || _request.logLevel === "debug";
      } else {
        return false;
      }
    }
    function _debug(msg) {
      if (_canLog("debug")) {
        atmosphere.util.debug(new Date() + " Atmosphere: " + msg);
      }
    }
    function _verifyStreamingLength(ajaxRequest, rq) {
      if (_response.partialMessage === "" && rq.transport === "streaming" && ajaxRequest.responseText.length > rq.maxStreamingLength) {
        return true;
      }
      return false;
    }
    function _disconnect() {
      if (_request.enableProtocol && !_request.disableDisconnect && !_request.firstMessage) {
        var query = "X-Atmosphere-Transport=close&X-Atmosphere-tracking-id=" + _request.uuid;
        atmosphere.util.each(_request.headers, function(name, value) {
          var h = atmosphere.util.isFunction(value) ? value.call(this, _request, _request, _response) : value;
          if (h != null) {
            query += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
          }
        });
        var url = _request.url.replace(/([?&])_=[^&]*/, query);
        url = url + (url === _request.url ? (/\?/.test(_request.url) ? "&" : "?") + query : "");
        var rq = {
          connected: false
        };
        var closeR = new atmosphere.AtmosphereRequest(rq);
        closeR.connectTimeout = _request.connectTimeout;
        closeR.attachHeadersAsQueryString = false;
        closeR.dropHeaders = true;
        closeR.url = url;
        closeR.contentType = "text/plain";
        closeR.transport = "polling";
        closeR.method = "GET";
        closeR.data = "";
        closeR.heartbeat = null;
        if (_request.enableXDR) {
          closeR.enableXDR = _request.enableXDR;
        }
        _pushOnClose("", closeR);
      }
    }
    function _close() {
      _debug("Closing (AtmosphereRequest._close() called)");
      _abortingConnection = true;
      if (_request.reconnectId) {
        clearTimeout(_request.reconnectId);
        delete _request.reconnectId;
      }
      if (_request.heartbeatTimer) {
        clearTimeout(_request.heartbeatTimer);
      }
      _request.reconnect = false;
      _response.request = _request;
      _response.state = "unsubscribe";
      _response.responseBody = "";
      _response.status = 408;
      _response.partialMessage = "";
      _request.curWebsocketErrorRetries = 0;
      _invokeCallback();
      _disconnect();
      _clearState();
    }
    function _clearState() {
      _response.partialMessage = "";
      if (_request.id) {
        clearTimeout(_request.id);
      }
      if (_request.heartbeatTimer) {
        clearTimeout(_request.heartbeatTimer);
      }
      if (_request.reconnectId) {
        clearTimeout(_request.reconnectId);
        delete _request.reconnectId;
      }
      if (_ieStream != null) {
        _ieStream.close();
        _ieStream = null;
      }
      if (_jqxhr != null) {
        _jqxhr.abort();
        _jqxhr = null;
      }
      if (_activeRequest != null) {
        _activeRequest.abort();
        _activeRequest = null;
      }
      if (_websocket != null) {
        if (_websocket.canSendMessage) {
          _debug("invoking .close() on WebSocket object");
          _websocket.close();
        }
        _websocket = null;
      }
      if (_sse != null) {
        _sse.close();
        _sse = null;
      }
      _clearStorage();
    }
    function _clearStorage() {
      if (_storageService != null) {
        clearInterval(_traceTimer);
        document.cookie = _sharingKey + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
        _storageService.signal("close", {
          reason: "",
          heir: !_abortingConnection ? guid2 : (_storageService.get("children") || [])[0]
        });
        _storageService.close();
      }
      if (_localStorageService != null) {
        _localStorageService.close();
      }
    }
    function _subscribe(options2) {
      _reinit();
      _request = atmosphere.util.extend(_request, options2);
      _request.mrequest = _request.reconnect;
      if (!_request.reconnect) {
        _request.reconnect = true;
      }
    }
    function _supportWebsocket() {
      return _request.webSocketImpl != null || window.WebSocket || window.MozWebSocket;
    }
    function _supportSSE() {
      var url = atmosphere.util.getAbsoluteURL(_request.url.toLowerCase());
      var parts = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/.exec(url);
      var crossOrigin = !!(parts && (parts[1] != window.location.protocol || parts[2] != window.location.hostname || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (window.location.port || (window.location.protocol === "http:" ? 80 : 443))));
      return window.EventSource && (!crossOrigin || !atmosphere.util.browser.safari || atmosphere.util.browser.vmajor >= 7);
    }
    function _execute() {
      if (_request.shared) {
        _localStorageService = _local(_request);
        if (_localStorageService != null) {
          if (_canLog("debug")) {
            atmosphere.util.debug(
              "Storage service available. All communication will be local"
            );
          }
          if (_localStorageService.open(_request)) {
            return;
          }
        }
        if (_canLog("debug")) {
          atmosphere.util.debug("No Storage service available.");
        }
        _localStorageService = null;
      }
      _request.firstMessage = uuid == 0 ? true : false;
      _request.isOpen = false;
      _request.ctime = atmosphere.util.now();
      if (_request.uuid === 0) {
        _request.uuid = uuid;
      }
      _response.closedByClientTimeout = false;
      if (_request.transport !== "websocket" && _request.transport !== "sse") {
        _executeRequest(_request);
      } else if (_request.transport === "websocket") {
        if (!_supportWebsocket()) {
          _reconnectWithFallbackTransport(
            "Websocket is not supported, using request.fallbackTransport (" + _request.fallbackTransport + ")"
          );
        } else {
          _executeWebSocket(false);
        }
      } else if (_request.transport === "sse") {
        if (!_supportSSE()) {
          _reconnectWithFallbackTransport(
            "Server Side Events(SSE) is not supported, using request.fallbackTransport (" + _request.fallbackTransport + ")"
          );
        } else {
          _executeSSE(false);
        }
      }
    }
    function _local(request) {
      var trace, connector, orphan, name = "atmosphere-" + request.url, connectors = {
        storage: function() {
          function onstorage(event) {
            if (event.key === name && event.newValue) {
              listener(event.newValue);
            }
          }
          if (!atmosphere.util.storage) {
            return;
          }
          var storage = window.localStorage, get = function(key) {
            var item = storage.getItem(name + "-" + key);
            return item === null ? [] : JSON.parse(item);
          }, set = function(key, value) {
            storage.setItem(name + "-" + key, JSON.stringify(value));
          };
          return {
            init: function() {
              set("children", get("children").concat([guid2]));
              atmosphere.util.on(window, "storage", onstorage);
              return get("opened");
            },
            signal: function(type, data) {
              storage.setItem(
                name,
                JSON.stringify({
                  target: "p",
                  type,
                  data
                })
              );
            },
            close: function() {
              var children = get("children");
              atmosphere.util.off(window, "storage", onstorage);
              if (children) {
                if (removeFromArray(children, request.id)) {
                  set("children", children);
                }
              }
            }
          };
        },
        windowref: function() {
          var win = window.open("", name.replace(/\W/g, ""));
          if (!win || win.closed || !win.callbacks) {
            return;
          }
          return {
            init: function() {
              win.callbacks.push(listener);
              win.children.push(guid2);
              return win.opened;
            },
            signal: function(type, data) {
              if (!win.closed && win.fire) {
                win.fire(
                  JSON.stringify({
                    target: "p",
                    type,
                    data
                  })
                );
              }
            },
            close: function() {
              if (!orphan) {
                removeFromArray(win.callbacks, listener);
                removeFromArray(win.children, guid2);
              }
            }
          };
        }
      };
      function removeFromArray(array, val) {
        var i, length = array.length;
        for (i = 0; i < length; i++) {
          if (array[i] === val) {
            array.splice(i, 1);
          }
        }
        return length !== array.length;
      }
      function listener(string) {
        var command = JSON.parse(string), data = command.data;
        if (command.target === "c") {
          switch (command.type) {
            case "open":
              _open("opening", "local", _request);
              break;
            case "close":
              if (!orphan) {
                orphan = true;
                if (data.reason === "aborted") {
                  _close();
                } else {
                  if (data.heir === guid2) {
                    _execute();
                  } else {
                    setTimeout(function() {
                      _execute();
                    }, 100);
                  }
                }
              }
              break;
            case "message":
              _prepareCallback(data, "messageReceived", 200, request.transport);
              break;
            case "localMessage":
              _localMessage(data);
              break;
          }
        }
      }
      function findTrace() {
        var matcher = new RegExp(
          "(?:^|; )(" + encodeURIComponent(name) + ")=([^;]*)"
        ).exec(document.cookie);
        if (matcher) {
          return JSON.parse(decodeURIComponent(matcher[2]));
        }
      }
      trace = findTrace();
      if (!trace || atmosphere.util.now() - trace.ts > 1e3) {
        return;
      }
      connector = connectors.storage() || connectors.windowref();
      if (!connector) {
        return;
      }
      return {
        open: function() {
          var parentOpened;
          _traceTimer = setInterval(function() {
            var oldTrace = trace;
            trace = findTrace();
            if (!trace || oldTrace.ts === trace.ts) {
              listener(
                JSON.stringify({
                  target: "c",
                  type: "close",
                  data: {
                    reason: "error",
                    heir: oldTrace.heir
                  }
                })
              );
            }
          }, 1e3);
          parentOpened = connector.init();
          if (parentOpened) {
            setTimeout(function() {
              _open("opening", "local", request);
            }, 50);
          }
          return parentOpened;
        },
        send: function(event) {
          connector.signal("send", event);
        },
        localSend: function(event) {
          connector.signal(
            "localSend",
            JSON.stringify({
              id: guid2,
              event
            })
          );
        },
        close: function() {
          if (!_abortingConnection) {
            clearInterval(_traceTimer);
            connector.signal("close");
            connector.close();
          }
        }
      };
    }
    function share() {
      var storageService, name = "atmosphere-" + _request.url, servers = {
        storage: function() {
          function onstorage(event) {
            if (event.key === name && event.newValue) {
              listener(event.newValue);
            }
          }
          if (!atmosphere.util.storage) {
            return;
          }
          var storage = window.localStorage;
          return {
            init: function() {
              atmosphere.util.on(window, "storage", onstorage);
            },
            signal: function(type, data) {
              storage.setItem(
                name,
                JSON.stringify({
                  target: "c",
                  type,
                  data
                })
              );
            },
            get: function(key) {
              return JSON.parse(storage.getItem(name + "-" + key));
            },
            set: function(key, value) {
              storage.setItem(name + "-" + key, JSON.stringify(value));
            },
            close: function() {
              atmosphere.util.off(window, "storage", onstorage);
              storage.removeItem(name);
              storage.removeItem(name + "-opened");
              storage.removeItem(name + "-children");
            }
          };
        },
        windowref: function() {
          var neim = name.replace(/\W/g, ""), container = document.getElementById(neim), win;
          if (!container) {
            container = document.createElement("div");
            container.id = neim;
            container.style.display = "none";
            container.innerHTML = '<iframe name="' + neim + '"></iframe>';
            document.body.appendChild(container);
          }
          win = container.firstChild.contentWindow;
          return {
            init: function() {
              win.callbacks = [listener];
              win.fire = function(string) {
                var i;
                for (i = 0; i < win.callbacks.length; i++) {
                  win.callbacks[i](string);
                }
              };
            },
            signal: function(type, data) {
              if (!win.closed && win.fire) {
                win.fire(
                  JSON.stringify({
                    target: "c",
                    type,
                    data
                  })
                );
              }
            },
            get: function(key) {
              return !win.closed ? win[key] : null;
            },
            set: function(key, value) {
              if (!win.closed) {
                win[key] = value;
              }
            },
            close: function() {
            }
          };
        }
      };
      function listener(string) {
        var command = JSON.parse(string), data = command.data;
        if (command.target === "p") {
          switch (command.type) {
            case "send":
              _push(data);
              break;
            case "localSend":
              _localMessage(data);
              break;
            case "close":
              _close();
              break;
          }
        }
      }
      _localSocketF = function propagateMessageEvent(context) {
        storageService.signal("message", context);
      };
      function leaveTrace() {
        document.cookie = _sharingKey + "=" + encodeURIComponent(
          JSON.stringify({
            ts: atmosphere.util.now() + 1,
            heir: (storageService.get("children") || [])[0]
          })
        ) + "; path=/";
      }
      storageService = servers.storage() || servers.windowref();
      storageService.init();
      if (_canLog("debug")) {
        atmosphere.util.debug("Installed StorageService " + storageService);
      }
      storageService.set("children", []);
      if (storageService.get("opened") != null && !storageService.get("opened")) {
        storageService.set("opened", false);
      }
      _sharingKey = encodeURIComponent(name);
      leaveTrace();
      _traceTimer = setInterval(leaveTrace, 1e3);
      _storageService = storageService;
    }
    function _open(state, transport, request) {
      if (_request.shared && transport !== "local") {
        share();
      }
      if (_storageService != null) {
        _storageService.set("opened", true);
      }
      request.close = function() {
        _close();
      };
      if (_requestCount > 0 && state === "re-connecting") {
        request.isReopen = true;
        _tryingToReconnect(_response);
      } else if (!_response.error) {
        _response.request = request;
        var prevState = _response.state;
        _response.state = state;
        var prevTransport = _response.transport;
        _response.transport = transport;
        var _body = _response.responseBody;
        _invokeCallback();
        _response.responseBody = _body;
        _response.state = prevState;
        _response.transport = prevTransport;
      }
    }
    function _jsonp(request) {
      request.transport = "jsonp";
      var rq = _request, script;
      if (request != null && typeof request !== "undefined") {
        rq = request;
      }
      _jqxhr = {
        open: function() {
          var callback = "atmosphere" + ++guid2;
          function _reconnectOnFailure() {
            rq.lastIndex = 0;
            if (rq.openId) {
              clearTimeout(rq.openId);
            }
            if (rq.heartbeatTimer) {
              clearTimeout(rq.heartbeatTimer);
            }
            if (rq.reconnect && _requestCount++ < rq.maxReconnectOnClose) {
              _open("re-connecting", rq.transport, rq);
              _reconnect(_jqxhr, rq, request.reconnectInterval);
              rq.openId = setTimeout(function() {
                _triggerOpen(rq);
              }, rq.reconnectInterval + 1e3);
            } else {
              _onError(0, "maxReconnectOnClose reached");
            }
          }
          function poll() {
            var url = rq.url;
            if (rq.dispatchUrl != null) {
              url += rq.dispatchUrl;
            }
            var data = rq.data;
            if (rq.attachHeadersAsQueryString) {
              url = _attachHeaders(rq);
              if (data !== "") {
                url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(data);
              }
              data = "";
            }
            var head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
            script = document.createElement("script");
            script.src = url + "&jsonpTransport=" + callback;
            script.clean = function() {
              script.clean = script.onerror = script.onload = script.onreadystatechange = null;
              if (script.parentNode) {
                script.parentNode.removeChild(script);
              }
              if (++request.scriptCount === 2) {
                request.scriptCount = 1;
                _reconnectOnFailure();
              }
            };
            script.onload = script.onreadystatechange = function() {
              _debug("jsonp.onload");
              if (!script.readyState || /loaded|complete/.test(script.readyState)) {
                script.clean();
              }
            };
            script.onerror = function() {
              _debug("jsonp.onerror");
              request.scriptCount = 1;
              script.clean();
            };
            head.insertBefore(script, head.firstChild);
          }
          window[callback] = function(msg) {
            _debug("jsonp.window");
            request.scriptCount = 0;
            if (rq.reconnect && rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest) {
              if (!rq.executeCallbackBeforeReconnect) {
                _reconnect(_jqxhr, rq, rq.pollingInterval);
              }
              if (msg != null && typeof msg !== "string") {
                try {
                  msg = msg.message;
                } catch (err) {
                }
              }
              var skipCallbackInvocation = _trackMessageSize(
                msg,
                rq,
                _response
              );
              if (!skipCallbackInvocation) {
                _prepareCallback(
                  _response.responseBody,
                  "messageReceived",
                  200,
                  rq.transport
                );
              }
              if (rq.executeCallbackBeforeReconnect) {
                _reconnect(_jqxhr, rq, rq.pollingInterval);
              }
              _timeout(rq);
            } else {
              atmosphere.util.log(_request.logLevel, [
                "JSONP reconnect maximum try reached " + _request.requestCount
              ]);
              _onError(0, "maxRequest reached");
            }
          };
          setTimeout(function() {
            poll();
          }, 50);
        },
        abort: function() {
          if (script && script.clean) {
            script.clean();
          }
        }
      };
      _jqxhr.open();
    }
    function _getWebSocket(location) {
      if (_request.webSocketImpl != null) {
        return _request.webSocketImpl;
      } else {
        if (window.WebSocket) {
          return new WebSocket(location);
        } else {
          return new MozWebSocket(location);
        }
      }
    }
    function _buildWebSocketUrl() {
      return _attachHeaders(
        _request,
        atmosphere.util.getAbsoluteURL(_request.webSocketUrl || _request.url)
      ).replace(/^http/, "ws");
    }
    function _buildSSEUrl() {
      var url = _attachHeaders(_request);
      return url;
    }
    function _executeSSE(sseOpened) {
      _response.transport = "sse";
      var location = _buildSSEUrl();
      if (_canLog("debug")) {
        atmosphere.util.debug("Invoking executeSSE");
        atmosphere.util.debug("Using URL: " + location);
      }
      if (sseOpened && !_request.reconnect) {
        if (_sse != null) {
          _clearState();
        }
        return;
      }
      try {
        _sse = new EventSource(location, {
          withCredentials: _request.withCredentials
        });
      } catch (e) {
        _onError(0, e);
        _reconnectWithFallbackTransport(
          "SSE failed. Downgrading to fallback transport and resending"
        );
        return;
      }
      if (_request.connectTimeout > 0) {
        _request.id = setTimeout(function() {
          if (!sseOpened) {
            _clearState();
          }
        }, _request.connectTimeout);
      }
      _sse.onopen = function() {
        _debug("sse.onopen");
        _timeout(_request);
        if (_canLog("debug")) {
          atmosphere.util.debug("SSE successfully opened");
        }
        if (!_request.enableProtocol) {
          if (!sseOpened) {
            _open("opening", "sse", _request);
          } else {
            _open("re-opening", "sse", _request);
          }
        } else if (_request.isReopen) {
          _request.isReopen = false;
          _open("re-opening", _request.transport, _request);
        }
        sseOpened = true;
        if (_request.method === "POST") {
          _response.state = "messageReceived";
          _push(_request.data);
        }
      };
      _sse.onmessage = function(message) {
        _debug("sse.onmessage");
        _timeout(_request);
        if (!_request.enableXDR && window.location.host && message.origin && message.origin !== window.location.protocol + "//" + window.location.host) {
          atmosphere.util.log(_request.logLevel, [
            "Origin was not " + window.location.protocol + "//" + window.location.host
          ]);
          return;
        }
        _response.state = "messageReceived";
        _response.status = 200;
        message = message.data;
        var skipCallbackInvocation = _trackMessageSize(
          message,
          _request,
          _response
        );
        if (!skipCallbackInvocation) {
          _invokeCallback();
          _response.responseBody = "";
          _response.messages = [];
        }
      };
      _sse.onerror = function() {
        _debug("sse.onerror");
        clearTimeout(_request.id);
        if (_request.heartbeatTimer) {
          clearTimeout(_request.heartbeatTimer);
        }
        if (_response.closedByClientTimeout) {
          return;
        }
        _invokeClose(sseOpened);
        _clearState();
        if (_abortingConnection) {
          atmosphere.util.log(_request.logLevel, ["SSE closed normally"]);
        } else if (!sseOpened) {
          _reconnectWithFallbackTransport(
            "SSE failed. Downgrading to fallback transport and resending"
          );
        } else if (_request.reconnect && _response.transport === "sse") {
          if (_requestCount++ < _request.maxReconnectOnClose) {
            _open("re-connecting", _request.transport, _request);
            if (_request.reconnectInterval > 0) {
              var handleOnlineOffline = _request.handleOnlineOffline;
              _request.handleOnlineOffline = false;
              _request.reconnectId = setTimeout(function() {
                _request.handleOnlineOffline = handleOnlineOffline;
                _executeSSE(true);
              }, _request.reconnectInterval);
            } else {
              _executeSSE(true);
            }
            _response.responseBody = "";
            _response.messages = [];
          } else {
            atmosphere.util.log(_request.logLevel, [
              "SSE reconnect maximum try reached " + _requestCount
            ]);
            _onError(0, "maxReconnectOnClose reached");
          }
        }
      };
    }
    function _executeWebSocket(webSocketOpened) {
      _response.transport = "websocket";
      var location = _buildWebSocketUrl(_request.url);
      if (_canLog("debug")) {
        atmosphere.util.debug(
          "Invoking executeWebSocket, using URL: " + location
        );
      }
      if (webSocketOpened && !_request.reconnect) {
        if (_websocket != null) {
          _clearState();
        }
        return;
      }
      _websocket = _getWebSocket(location);
      if (_request.webSocketBinaryType != null) {
        _websocket.binaryType = _request.webSocketBinaryType;
      }
      if (_request.connectTimeout > 0) {
        _request.id = setTimeout(function() {
          if (!webSocketOpened) {
            var _message = {
              code: 1002,
              reason: "Connection timeout after " + _request.connectTimeout + "ms.",
              wasClean: false
            };
            var socket = _websocket;
            try {
              _clearState();
            } catch (e) {
            }
            socket.onclose(_message);
          }
        }, _request.connectTimeout);
      }
      _websocket.onopen = function() {
        if (_websocket == null) {
          this.close();
          if (_request.transport == "websocket")
            _close();
          return;
        }
        _debug("websocket.onopen");
        if (!_request.enableProtocol || _request.connectTimeout <= 0)
          _timeout(_request);
        offline = false;
        if (_canLog("debug")) {
          atmosphere.util.debug("Websocket successfully opened");
        }
        var reopening = webSocketOpened;
        _websocket.canSendMessage = true;
        if (!_request.enableProtocol) {
          webSocketOpened = true;
          if (reopening) {
            _open("re-opening", "websocket", _request);
          } else {
            _open("opening", "websocket", _request);
          }
        }
        if (_request.method === "POST") {
          _response.state = "messageReceived";
          _websocket.send(_request.data);
        }
      };
      _websocket.onmessage = function(message) {
        if (_websocket == null) {
          this.close();
          if (_request.transport == "websocket")
            _close();
          return;
        }
        _debug("websocket.onmessage");
        _timeout(_request);
        if (_request.enableProtocol) {
          webSocketOpened = true;
        }
        _response.state = "messageReceived";
        _response.status = 200;
        message = message.data;
        var isString = typeof message === "string";
        if (isString) {
          var skipCallbackInvocation = _trackMessageSize(
            message,
            _request,
            _response
          );
          if (!skipCallbackInvocation) {
            _invokeCallback();
            _response.responseBody = "";
            _response.messages = [];
          }
        } else {
          message = _handleProtocol(_request, message);
          if (message === "")
            return;
          _response.responseBody = message;
          _invokeCallback();
          _response.responseBody = null;
        }
      };
      _websocket.onerror = function() {
        _debug("websocket.onerror");
        clearTimeout(_request.id);
        if (_request.heartbeatTimer) {
          clearTimeout(_request.heartbeatTimer);
        }
        _response.error = true;
      };
      _websocket.onclose = function(message) {
        _debug("websocket.onclose");
        if (_response.transport !== "websocket")
          return;
        clearTimeout(_request.id);
        if (_response.state === "closed")
          return;
        var reason = message.reason;
        if (reason === "") {
          switch (message.code) {
            case 1e3:
              reason = "Normal closure; the connection successfully completed whatever purpose for which it was created.";
              break;
            case 1001:
              reason = "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.";
              break;
            case 1002:
              reason = "The endpoint is terminating the connection due to a protocol error.";
              break;
            case 1003:
              reason = "The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).";
              break;
            case 1004:
              reason = "The endpoint is terminating the connection because a data frame was received that is too large.";
              break;
            case 1005:
              reason = "Unknown: no status code was provided even though one was expected.";
              break;
            case 1006:
              reason = "Connection was closed abnormally (that is, with no close frame being sent).";
              break;
          }
        }
        if (_canLog("warn")) {
          atmosphere.util.warn(
            "Websocket closed, reason: " + reason + " - wasClean: " + message.wasClean
          );
        }
        if (_response.closedByClientTimeout || _request.handleOnlineOffline && offline) {
          if (_request.reconnectId) {
            clearTimeout(_request.reconnectId);
            delete _request.reconnectId;
          }
          return;
        }
        _invokeClose(webSocketOpened);
        _response.state = "closed";
        if (_abortingConnection) {
          atmosphere.util.log(_request.logLevel, ["Websocket closed normally"]);
        } else if (_response.error && _request.curWebsocketErrorRetries < _request.maxWebsocketErrorRetries && _requestCount + 1 < _request.maxReconnectOnClose) {
          _response.error = false;
          _request.curWebsocketErrorRetries++;
          _reconnectWebSocket();
        } else if ((_response.error || !webSocketOpened || _request.maxWebsocketErrorRetries === 0) && _request.fallbackTransport !== "websocket") {
          _response.error = false;
          _reconnectWithFallbackTransport(
            "Websocket failed on first connection attempt. Downgrading to " + _request.fallbackTransport + " and resending"
          );
        } else if (_request.reconnect) {
          _reconnectWebSocket();
        }
      };
      var ua = navigator.userAgent.toLowerCase();
      var isAndroid = ua.indexOf("android") > -1;
      if (isAndroid && _websocket.url === void 0) {
        _websocket.onclose({
          reason: "Android 4.1 does not support websockets.",
          wasClean: false
        });
      }
    }
    function _handleProtocol(request, message) {
      var nMessage = message;
      if (request.transport === "polling")
        return nMessage;
      if (request.enableProtocol && request.firstMessage && atmosphere.util.trim(message).length !== 0) {
        var pos = request.trackMessageLength ? 1 : 0;
        var messages = message.split(request.messageDelimiter);
        if (messages.length <= pos + 1) {
          return nMessage;
        }
        request.firstMessage = false;
        request.uuid = atmosphere.util.trim(messages[pos]);
        if (messages.length <= pos + 2) {
          atmosphere.util.log("error", [
            "Protocol data not sent by the server. If you enable protocol on client side, be sure to install JavascriptProtocol interceptor on server side.Also note that atmosphere-runtime 2.2+ should be used."
          ]);
        }
        _heartbeatInterval = parseInt(
          atmosphere.util.trim(messages[pos + 1]),
          10
        );
        _heartbeatPadding = messages[pos + 2];
        if (request.transport !== "long-polling") {
          _triggerOpen(request);
        }
        uuid = request.uuid;
        nMessage = "";
        pos = request.trackMessageLength ? 4 : 3;
        if (messages.length > pos + 1) {
          for (var i = pos; i < messages.length; i++) {
            nMessage += messages[i];
            if (i + 1 !== messages.length) {
              nMessage += request.messageDelimiter;
            }
          }
        }
        if (request.ackInterval !== 0) {
          setTimeout(function() {
            _push("...ACK...");
          }, request.ackInterval);
        }
      } else if (request.enableProtocol && request.firstMessage && atmosphere.util.browser.msie && +atmosphere.util.browser.version.split(".")[0] < 10) {
        atmosphere.util.log(_request.logLevel, [
          "Receiving unexpected data from IE"
        ]);
      } else {
        _triggerOpen(request);
      }
      return nMessage;
    }
    function _timeout(_request2) {
      clearTimeout(_request2.id);
      if (_request2.timeout > 0 && _request2.transport !== "polling") {
        _request2.id = setTimeout(function() {
          _onClientTimeout(_request2);
          _disconnect();
          _clearState();
        }, _request2.timeout);
      }
    }
    function _onClientTimeout(_request2) {
      _response.closedByClientTimeout = true;
      _response.state = "closedByClient";
      _response.responseBody = "";
      _response.status = 408;
      _response.messages = [];
      _invokeCallback();
    }
    function _onError(code, reason) {
      _clearState();
      clearTimeout(_request.id);
      _response.state = "error";
      _response.reasonPhrase = reason;
      _response.responseBody = "";
      _response.status = code;
      _response.messages = [];
      _invokeCallback();
    }
    function _trackMessageSize(message, request, response) {
      message = _handleProtocol(request, message);
      if (message.length === 0)
        return true;
      response.responseBody = message;
      if (request.trackMessageLength) {
        message = response.partialMessage + message;
        var messages = [];
        var messageStart = message.indexOf(request.messageDelimiter);
        if (messageStart != -1) {
          while (messageStart !== -1) {
            var str = message.substring(0, messageStart);
            var messageLength = +str;
            if (isNaN(messageLength)) {
              response.partialMessage = "";
              throw new Error('message length "' + str + '" is not a number');
            }
            messageStart += request.messageDelimiter.length;
            if (messageStart + messageLength > message.length) {
              messageStart = -1;
            } else {
              messages.push(
                message.substring(messageStart, messageStart + messageLength)
              );
              message = message.substring(
                messageStart + messageLength,
                message.length
              );
              messageStart = message.indexOf(request.messageDelimiter);
            }
          }
          response.partialMessage = message;
          if (messages.length !== 0) {
            response.responseBody = messages.join(request.messageDelimiter);
            response.messages = messages;
            return false;
          } else {
            response.responseBody = "";
            response.messages = [];
            return true;
          }
        }
      }
      response.responseBody = message;
      response.messages = [message];
      return false;
    }
    function _reconnectWebSocket() {
      _clearState();
      if (_requestCount++ < _request.maxReconnectOnClose) {
        _open("re-connecting", _request.transport, _request);
        if (_request.reconnectInterval > 0) {
          var handleOnlineOffline = _request.handleOnlineOffline;
          _request.handleOnlineOffline = false;
          _request.reconnectId = setTimeout(function() {
            _request.handleOnlineOffline = handleOnlineOffline;
            _response.responseBody = "";
            _response.messages = [];
            _executeWebSocket(true);
          }, _request.reconnectInterval);
        } else {
          _response.responseBody = "";
          _response.messages = [];
          _executeWebSocket(true);
        }
      } else {
        atmosphere.util.log(_request.logLevel, [
          "Websocket reconnect maximum try reached " + _requestCount
        ]);
        _onError(0, "maxReconnectOnClose reached");
      }
    }
    function _reconnectWithFallbackTransport(errorMessage) {
      atmosphere.util.log(_request.logLevel, [errorMessage]);
      _clearState();
      if (typeof _request.onTransportFailure !== "undefined") {
        _request.onTransportFailure(errorMessage, _request);
      } else if (typeof atmosphere.util.onTransportFailure !== "undefined") {
        atmosphere.util.onTransportFailure(errorMessage, _request);
      }
      if (_request.reconnect && _request.transport !== "none" || _request.transport == null) {
        _request.transport = _request.fallbackTransport;
        _request.method = _request.fallbackMethod;
        _response.transport = _request.fallbackTransport;
        _response.state = "";
        _request.fallbackTransport = "none";
        if (_request.reconnectInterval > 0) {
          var handleOnlineOffline = _request.handleOnlineOffline;
          _request.handleOnlineOffline = false;
          _request.reconnectId = setTimeout(function() {
            _request.handleOnlineOffline = handleOnlineOffline;
            _execute();
          }, _request.reconnectInterval);
        } else {
          _execute();
        }
      } else {
        _onError(500, "Unable to reconnect with fallback transport");
      }
    }
    function _attachHeaders(request, url) {
      var rq = _request;
      if (request != null && typeof request !== "undefined") {
        rq = request;
      }
      if (url == null) {
        url = rq.url;
      }
      if (!rq.attachHeadersAsQueryString)
        return url;
      if (url.indexOf("X-Atmosphere-Framework") !== -1) {
        return url;
      }
      url += url.indexOf("?") !== -1 ? "&" : "?";
      url += "X-Atmosphere-tracking-id=" + rq.uuid;
      url += "&X-Atmosphere-Framework=" + atmosphere.version;
      url += "&X-Atmosphere-Transport=" + rq.transport;
      if (rq.trackMessageLength) {
        url += "&X-Atmosphere-TrackMessageSize=true";
      }
      if (rq.heartbeat !== null && rq.heartbeat.server !== null) {
        url += "&X-Heartbeat-Server=" + rq.heartbeat.server;
      }
      if (rq.contentType !== "") {
        url += "&Content-Type=" + (rq.transport === "websocket" ? rq.contentType : encodeURIComponent(rq.contentType));
      }
      if (rq.enableProtocol) {
        url += "&X-atmo-protocol=true";
      }
      atmosphere.util.each(rq.headers, function(name, value) {
        var h = atmosphere.util.isFunction(value) ? value.call(this, rq, request, _response) : value;
        if (h != null) {
          url += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
        }
      });
      return url;
    }
    function _triggerOpen(rq) {
      if (!rq.isOpen) {
        rq.isOpen = true;
        _open("opening", rq.transport, rq);
      } else if (rq.isReopen) {
        rq.isReopen = false;
        _open("re-opening", rq.transport, rq);
      } else if (_response.state === "messageReceived" && (rq.transport === "jsonp" || rq.transport === "long-polling")) {
        _openAfterResume(_response);
      } else {
        return;
      }
      _startHeartbeat(rq);
    }
    function _startHeartbeat(rq) {
      if (rq.heartbeatTimer != null) {
        clearTimeout(rq.heartbeatTimer);
      }
      if (!isNaN(_heartbeatInterval) && _heartbeatInterval > 0) {
        var _pushHeartbeat = function() {
          if (_canLog("debug")) {
            atmosphere.util.debug("Sending heartbeat");
          }
          _push(_heartbeatPadding);
          rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
        };
        rq.heartbeatTimer = setTimeout(_pushHeartbeat, _heartbeatInterval);
      }
    }
    function _executeRequest(request) {
      var rq = _request;
      if (request != null || typeof request !== "undefined") {
        rq = request;
      }
      rq.lastIndex = 0;
      rq.readyState = 0;
      if (rq.transport === "jsonp" || rq.enableXDR && atmosphere.util.checkCORSSupport()) {
        _jsonp(rq);
        return;
      }
      if (atmosphere.util.browser.msie && +atmosphere.util.browser.version.split(".")[0] < 10) {
        if (rq.transport === "streaming") {
          if (rq.enableXDR && window.XDomainRequest) {
            _ieXDR(rq);
          } else {
            _ieStreaming(rq);
          }
          return;
        }
        if (rq.enableXDR && window.XDomainRequest) {
          _ieXDR(rq);
          return;
        }
      }
      var reconnectFExec = function(force) {
        rq.lastIndex = 0;
        _requestCount++;
        if (force || rq.reconnect && _requestCount <= rq.maxReconnectOnClose) {
          var delay = force ? 0 : request.reconnectInterval;
          _response.ffTryingReconnect = true;
          _open("re-connecting", request.transport, request);
          _reconnect(ajaxRequest, rq, delay);
        } else {
          _onError(0, "maxReconnectOnClose reached");
        }
      };
      var reconnectF = function(force) {
        if (atmosphere._beforeUnloadState) {
          atmosphere.util.debug(
            new Date() + " Atmosphere: reconnectF: execution delayed due to _beforeUnloadState flag"
          );
          setTimeout(function() {
            reconnectFExec(force);
          }, 5e3);
        } else {
          reconnectFExec(force);
        }
      };
      var disconnected = function() {
        _response.errorHandled = true;
        _clearState();
        reconnectF(false);
      };
      if (rq.force || rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest)) {
        rq.force = false;
        var ajaxRequest = atmosphere.util.xhr();
        ajaxRequest.hasData = false;
        _doRequest(ajaxRequest, rq, true);
        if (rq.suspend) {
          _activeRequest = ajaxRequest;
        }
        if (rq.transport !== "polling") {
          _response.transport = rq.transport;
          ajaxRequest.onabort = function() {
            _debug("ajaxrequest.onabort");
            _invokeClose(true);
          };
          ajaxRequest.onerror = function() {
            _debug("ajaxrequest.onerror");
            _response.error = true;
            _response.ffTryingReconnect = true;
            try {
              _response.status = XMLHttpRequest.status;
            } catch (e) {
              _response.status = 500;
            }
            if (!_response.status) {
              _response.status = 500;
            }
            if (!_response.errorHandled) {
              _clearState();
              reconnectF(false);
            }
          };
        }
        ajaxRequest.onreadystatechange = function() {
          _debug(
            "ajaxRequest.onreadystatechange, new state: " + ajaxRequest.readyState
          );
          if (_abortingConnection) {
            _debug(
              "onreadystatechange has been ignored due to _abortingConnection flag"
            );
            return;
          }
          _response.error = false;
          var skipCallbackInvocation = false;
          var update = false;
          if (rq.transport === "streaming" && rq.readyState > 2 && ajaxRequest.readyState === 4) {
            _clearState();
            reconnectF(false);
            return;
          }
          rq.readyState = ajaxRequest.readyState;
          if (rq.transport === "streaming" && ajaxRequest.readyState >= 3) {
            update = true;
          } else if (rq.transport === "long-polling" && ajaxRequest.readyState === 4) {
            update = true;
          }
          _timeout(_request);
          if (rq.transport !== "polling") {
            var status = 200;
            if (ajaxRequest.readyState === 4) {
              status = ajaxRequest.status > 1e3 ? 0 : ajaxRequest.status;
            }
            if (!rq.reconnectOnServerError && status >= 300 && status < 600) {
              _onError(status, ajaxRequest.statusText);
              return;
            }
            if (status >= 300 || status === 0) {
              if (!rq.isOpen && _canLog("warn")) {
                atmosphere.util.warn(
                  rq.transport + " connection failed with status: " + status + " " + (ajaxRequest.statusText || "Unable to connect")
                );
              }
              disconnected();
              return;
            }
            if ((!rq.enableProtocol || !request.firstMessage) && (ajaxRequest.readyState === 2 || ajaxRequest.readyState > 2 && !rq.isOpen)) {
              if (atmosphere.util.browser.mozilla && _response.ffTryingReconnect) {
                _response.ffTryingReconnect = false;
                setTimeout(function() {
                  if (!_response.ffTryingReconnect) {
                    _triggerOpen(rq);
                  }
                }, 500);
              } else {
                _triggerOpen(rq);
              }
            }
          } else if (ajaxRequest.readyState === 4) {
            update = true;
          }
          if (update) {
            var responseText = ajaxRequest.responseText;
            _response.errorHandled = false;
            if (rq.transport === "long-polling" && atmosphere.util.trim(responseText).length === 0) {
              if (!ajaxRequest.hasData) {
                reconnectF(true);
              } else {
                ajaxRequest.hasData = false;
              }
              return;
            }
            ajaxRequest.hasData = true;
            _readHeaders(ajaxRequest, _request);
            if (rq.transport === "streaming") {
              if (!atmosphere.util.browser.opera) {
                var message = responseText.substring(
                  rq.lastIndex,
                  responseText.length
                );
                skipCallbackInvocation = _trackMessageSize(
                  message,
                  rq,
                  _response
                );
                rq.lastIndex = responseText.length;
                if (skipCallbackInvocation) {
                  return;
                }
              } else {
                atmosphere.util.iterate(function() {
                  if (_response.status !== 500 && ajaxRequest.responseText.length > rq.lastIndex) {
                    try {
                      _response.status = ajaxRequest.status;
                      _response.headers = atmosphere.util.parseHeaders(
                        ajaxRequest.getAllResponseHeaders()
                      );
                      _readHeaders(ajaxRequest, _request);
                    } catch (e) {
                      _response.status = 404;
                    }
                    _timeout(_request);
                    _response.state = "messageReceived";
                    var message2 = ajaxRequest.responseText.substring(
                      rq.lastIndex
                    );
                    rq.lastIndex = ajaxRequest.responseText.length;
                    skipCallbackInvocation = _trackMessageSize(
                      message2,
                      rq,
                      _response
                    );
                    if (!skipCallbackInvocation) {
                      _invokeCallback();
                    }
                    if (_verifyStreamingLength(ajaxRequest, rq)) {
                      _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                      return;
                    }
                  } else if (_response.status > 400) {
                    rq.lastIndex = ajaxRequest.responseText.length;
                    return false;
                  }
                }, 0);
              }
            } else {
              skipCallbackInvocation = _trackMessageSize(
                responseText,
                rq,
                _response
              );
            }
            var closeStream = _verifyStreamingLength(ajaxRequest, rq);
            try {
              _response.status = ajaxRequest.status;
              _response.headers = atmosphere.util.parseHeaders(
                ajaxRequest.getAllResponseHeaders()
              );
              _readHeaders(ajaxRequest, rq);
            } catch (e) {
              _response.status = 404;
            }
            if (rq.suspend) {
              _response.state = _response.status === 0 ? "closed" : "messageReceived";
            } else {
              _response.state = "messagePublished";
            }
            var isAllowedToReconnect = !closeStream && request.transport !== "streaming" && request.transport !== "polling";
            if (isAllowedToReconnect && !rq.executeCallbackBeforeReconnect) {
              _reconnect(ajaxRequest, rq, rq.pollingInterval);
            }
            if (_response.responseBody.length !== 0 && !skipCallbackInvocation)
              _invokeCallback();
            if (isAllowedToReconnect && rq.executeCallbackBeforeReconnect) {
              _reconnect(ajaxRequest, rq, rq.pollingInterval);
            }
            if (closeStream) {
              _reconnectOnMaxStreamingLength(ajaxRequest, rq);
            }
          }
        };
        try {
          ajaxRequest.send(rq.data);
          _subscribed = true;
        } catch (e) {
          atmosphere.util.log(rq.logLevel, ["Unable to connect to " + rq.url]);
          _onError(0, e);
        }
      } else {
        if (rq.logLevel === "debug") {
          atmosphere.util.log(rq.logLevel, ["Max re-connection reached."]);
        }
        _onError(0, "maxRequest reached");
      }
    }
    function _reconnectOnMaxStreamingLength(ajaxRequest, rq) {
      _response.messages = [];
      rq.isReopen = true;
      _close();
      _abortingConnection = false;
      _reconnect(ajaxRequest, rq, 500);
    }
    function _doRequest(ajaxRequest, request, create) {
      var url = request.url;
      if (request.dispatchUrl != null && request.method === "POST") {
        url += request.dispatchUrl;
      }
      url = _attachHeaders(request, url);
      url = atmosphere.util.prepareURL(url);
      if (create) {
        ajaxRequest.open(request.method, url, true);
        if (request.connectTimeout > 0) {
          request.id = setTimeout(function() {
            if (request.requestCount === 0) {
              _clearState();
              _prepareCallback(
                "Connect timeout",
                "closed",
                200,
                request.transport
              );
            }
          }, request.connectTimeout);
        }
      }
      if (_request.withCredentials && _request.transport !== "websocket") {
        if ("withCredentials" in ajaxRequest) {
          ajaxRequest.withCredentials = true;
        }
      }
      if (!_request.dropHeaders) {
        ajaxRequest.setRequestHeader(
          "X-Atmosphere-Framework",
          atmosphere.version
        );
        ajaxRequest.setRequestHeader(
          "X-Atmosphere-Transport",
          request.transport
        );
        if (request.heartbeat !== null && request.heartbeat.server !== null) {
          ajaxRequest.setRequestHeader(
            "X-Heartbeat-Server",
            ajaxRequest.heartbeat.server
          );
        }
        if (request.trackMessageLength) {
          ajaxRequest.setRequestHeader("X-Atmosphere-TrackMessageSize", "true");
        }
        ajaxRequest.setRequestHeader("X-Atmosphere-tracking-id", request.uuid);
        atmosphere.util.each(request.headers, function(name, value) {
          var h = atmosphere.util.isFunction(value) ? value.call(this, ajaxRequest, request, create, _response) : value;
          if (h != null) {
            ajaxRequest.setRequestHeader(name, h);
          }
        });
      }
      if (request.contentType !== "") {
        ajaxRequest.setRequestHeader("Content-Type", request.contentType);
      }
    }
    function _reconnect(ajaxRequest, request, delay) {
      if (_response.closedByClientTimeout) {
        return;
      }
      if (request.reconnect || request.suspend && _subscribed) {
        var status = 0;
        if (ajaxRequest && ajaxRequest.readyState > 1) {
          status = ajaxRequest.status > 1e3 ? 0 : ajaxRequest.status;
        }
        _response.status = status === 0 ? 204 : status;
        _response.reason = status === 0 ? "Server resumed the connection or down." : "OK";
        clearTimeout(request.id);
        if (request.reconnectId) {
          clearTimeout(request.reconnectId);
          delete request.reconnectId;
        }
        if (delay > 0) {
          var handleOnlineOffline = _request.handleOnlineOffline;
          _request.handleOnlineOffline = false;
          _request.reconnectId = setTimeout(function() {
            _request.handleOnlineOffline = handleOnlineOffline;
            _executeRequest(request);
          }, delay);
        } else {
          _executeRequest(request);
        }
      }
    }
    function _tryingToReconnect(response) {
      response.state = "re-connecting";
      _invokeFunction(response);
    }
    function _openAfterResume(response) {
      response.state = "openAfterResume";
      _invokeFunction(response);
      response.state = "messageReceived";
    }
    function _ieXDR(request) {
      if (request.transport !== "polling") {
        _ieStream = _configureXDR(request);
        _ieStream.open();
      } else {
        _configureXDR(request).open();
      }
    }
    function _configureXDR(request) {
      var rq = _request;
      if (request != null && typeof request !== "undefined") {
        rq = request;
      }
      var transport = rq.transport;
      var lastIndex = 0;
      var xdr = new window.XDomainRequest();
      var reconnect = function() {
        if (rq.transport === "long-polling" && rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest)) {
          xdr.status = 200;
          _ieXDR(rq);
        }
      };
      var rewriteURL = rq.rewriteURL || function(url) {
        var match = /(?:^|;\s*)(JSESSIONID|PHPSESSID)=([^;]*)/.exec(
          document.cookie
        );
        switch (match && match[1]) {
          case "JSESSIONID":
            return url.replace(
              /;jsessionid=[^\?]*|(\?)|$/,
              ";jsessionid=" + match[2] + "$1"
            );
          case "PHPSESSID":
            return url.replace(
              /\?PHPSESSID=[^&]*&?|\?|$/,
              "?PHPSESSID=" + match[2] + "&"
            ).replace(/&$/, "");
        }
        return url;
      };
      xdr.onprogress = function() {
        handle(xdr);
      };
      xdr.onerror = function() {
        if (rq.transport !== "polling") {
          _clearState();
          if (_requestCount++ < rq.maxReconnectOnClose) {
            if (rq.reconnectInterval > 0) {
              rq.reconnectId = setTimeout(function() {
                _open("re-connecting", request.transport, request);
                _ieXDR(rq);
              }, rq.reconnectInterval);
            } else {
              _open("re-connecting", request.transport, request);
              _ieXDR(rq);
            }
          } else {
            _onError(0, "maxReconnectOnClose reached");
          }
        }
      };
      xdr.onload = function() {
      };
      var handle = function(xdr2) {
        clearTimeout(rq.id);
        var message = xdr2.responseText;
        message = message.substring(lastIndex);
        lastIndex += message.length;
        if (transport !== "polling") {
          _timeout(rq);
          var skipCallbackInvocation = _trackMessageSize(
            message,
            rq,
            _response
          );
          if (transport === "long-polling" && atmosphere.util.trim(message).length === 0)
            return;
          if (rq.executeCallbackBeforeReconnect) {
            reconnect();
          }
          if (!skipCallbackInvocation) {
            _prepareCallback(
              _response.responseBody,
              "messageReceived",
              200,
              transport
            );
          }
          if (!rq.executeCallbackBeforeReconnect) {
            reconnect();
          }
        }
      };
      return {
        open: function() {
          var url = rq.url;
          if (rq.dispatchUrl != null) {
            url += rq.dispatchUrl;
          }
          url = _attachHeaders(rq, url);
          xdr.open(rq.method, rewriteURL(url));
          if (rq.method === "GET") {
            xdr.send();
          } else {
            xdr.send(rq.data);
          }
          if (rq.connectTimeout > 0) {
            rq.id = setTimeout(function() {
              if (rq.requestCount === 0) {
                _clearState();
                _prepareCallback(
                  "Connect timeout",
                  "closed",
                  200,
                  rq.transport
                );
              }
            }, rq.connectTimeout);
          }
        },
        close: function() {
          xdr.abort();
        }
      };
    }
    function _ieStreaming(request) {
      _ieStream = _configureIE(request);
      _ieStream.open();
    }
    function _configureIE(request) {
      var rq = _request;
      if (request != null && typeof request !== "undefined") {
        rq = request;
      }
      var stop;
      var doc = new window.ActiveXObject("htmlfile");
      doc.open();
      doc.close();
      var url = rq.url;
      if (rq.dispatchUrl != null) {
        url += rq.dispatchUrl;
      }
      if (rq.transport !== "polling") {
        _response.transport = rq.transport;
      }
      return {
        open: function() {
          var iframe = doc.createElement("iframe");
          url = _attachHeaders(rq);
          if (rq.data !== "") {
            url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(rq.data);
          }
          url = atmosphere.util.prepareURL(url);
          iframe.src = url;
          doc.body.appendChild(iframe);
          var cdoc = iframe.contentDocument || iframe.contentWindow.document;
          stop = atmosphere.util.iterate(function() {
            try {
              if (!cdoc.firstChild) {
                return;
              }
              var res = cdoc.body ? cdoc.body.lastChild : cdoc;
              if (res.omgThisIsBroken) {
              }
              var readResponse = function() {
                var clone = res.cloneNode(true);
                clone.appendChild(cdoc.createTextNode("."));
                var text = clone.innerText;
                text = text.substring(0, text.length - 1);
                return text;
              };
              if (!cdoc.body || !cdoc.body.firstChild || cdoc.body.firstChild.nodeName.toLowerCase() !== "pre") {
                var head = cdoc.head || cdoc.getElementsByTagName("head")[0] || cdoc.documentElement || cdoc;
                var script = cdoc.createElement("script");
                script.text = "document.write('<plaintext>')";
                head.insertBefore(script, head.firstChild);
                head.removeChild(script);
                res = cdoc.body.lastChild;
              }
              if (rq.closed) {
                rq.isReopen = true;
              }
              stop = atmosphere.util.iterate(function() {
                var text = readResponse();
                if (text.length > rq.lastIndex) {
                  _timeout(_request);
                  _response.status = 200;
                  _response.error = false;
                  res.innerText = "";
                  var skipCallbackInvocation = _trackMessageSize(
                    text,
                    rq,
                    _response
                  );
                  if (skipCallbackInvocation) {
                    return "";
                  }
                  _prepareCallback(
                    _response.responseBody,
                    "messageReceived",
                    200,
                    rq.transport
                  );
                }
                rq.lastIndex = 0;
                if (cdoc.readyState === "complete") {
                  _invokeClose(true);
                  _open("re-connecting", rq.transport, rq);
                  if (rq.reconnectInterval > 0) {
                    rq.reconnectId = setTimeout(function() {
                      _ieStreaming(rq);
                    }, rq.reconnectInterval);
                  } else {
                    _ieStreaming(rq);
                  }
                  return false;
                }
              }, null);
              return false;
            } catch (err) {
              _response.error = true;
              _open("re-connecting", rq.transport, rq);
              if (_requestCount++ < rq.maxReconnectOnClose) {
                if (rq.reconnectInterval > 0) {
                  rq.reconnectId = setTimeout(function() {
                    _ieStreaming(rq);
                  }, rq.reconnectInterval);
                } else {
                  _ieStreaming(rq);
                }
              } else {
                _onError(0, "maxReconnectOnClose reached");
              }
              doc.execCommand("Stop");
              doc.close();
              return false;
            }
          });
        },
        close: function() {
          if (stop) {
            stop();
          }
          doc.execCommand("Stop");
          _invokeClose(true);
        }
      };
    }
    function _push(message) {
      if (_localStorageService != null) {
        _pushLocal(message);
      } else if (_activeRequest != null || _sse != null) {
        _pushAjaxMessage(message);
      } else if (_ieStream != null) {
        _pushIE(message);
      } else if (_jqxhr != null) {
        _pushJsonp(message);
      } else if (_websocket != null) {
        _pushWebSocket(message);
      } else {
        _onError(0, "No suspended connection available");
        atmosphere.util.error(
          "No suspended connection available. Make sure atmosphere.subscribe has been called and request.onOpen invoked before trying to push data"
        );
      }
    }
    function _pushOnClose(message, rq) {
      if (!rq) {
        rq = _getPushRequest(message);
      }
      rq.transport = "polling";
      rq.method = "GET";
      rq.withCredentials = false;
      rq.reconnect = false;
      rq.force = true;
      rq.suspend = false;
      rq.timeout = 1e3;
      if (_request.unloadBackwardCompat) {
        _executeRequest(rq);
      } else {
        navigator.sendBeacon(rq.url, rq.data);
      }
    }
    function _pushLocal(message) {
      _localStorageService.send(message);
    }
    function _intraPush(message) {
      if (message.length === 0)
        return;
      try {
        if (_localStorageService) {
          _localStorageService.localSend(message);
        } else if (_storageService) {
          _storageService.signal(
            "localMessage",
            JSON.stringify({
              id: guid2,
              event: message
            })
          );
        }
      } catch (err) {
        atmosphere.util.error(err);
      }
    }
    function _pushAjaxMessage(message) {
      var rq = _getPushRequest(message);
      _executeRequest(rq);
    }
    function _pushIE(message) {
      if (_request.enableXDR && atmosphere.util.checkCORSSupport()) {
        var rq = _getPushRequest(message);
        rq.reconnect = false;
        _jsonp(rq);
      } else {
        _pushAjaxMessage(message);
      }
    }
    function _pushJsonp(message) {
      _pushAjaxMessage(message);
    }
    function _getStringMessage(message) {
      var msg = message;
      if (typeof msg === "object") {
        msg = message.data;
      }
      return msg;
    }
    function _getPushRequest(message) {
      var msg = _getStringMessage(message);
      var rq = {
        connected: false,
        timeout: 6e4,
        method: "POST",
        url: _request.url,
        contentType: _request.contentType,
        headers: _request.headers,
        reconnect: true,
        callback: null,
        data: msg,
        suspend: false,
        maxRequest: -1,
        logLevel: "info",
        requestCount: 0,
        withCredentials: _request.withCredentials,
        transport: "polling",
        isOpen: true,
        attachHeadersAsQueryString: true,
        enableXDR: _request.enableXDR,
        uuid: _request.uuid,
        dispatchUrl: _request.dispatchUrl,
        enableProtocol: false,
        messageDelimiter: "|",
        trackMessageLength: _request.trackMessageLength,
        maxReconnectOnClose: _request.maxReconnectOnClose,
        heartbeatTimer: _request.heartbeatTimer,
        heartbeat: _request.heartbeat
      };
      if (typeof message === "object") {
        rq = atmosphere.util.extend(rq, message);
      }
      return rq;
    }
    function _pushWebSocket(message) {
      var msg = atmosphere.util.isBinary(message) ? message : _getStringMessage(message);
      var data;
      try {
        if (_request.dispatchUrl != null) {
          data = _request.webSocketPathDelimiter + _request.dispatchUrl + _request.webSocketPathDelimiter + msg;
        } else {
          data = msg;
        }
        if (!_websocket.canSendMessage) {
          atmosphere.util.error("WebSocket not connected.");
          return;
        }
        _websocket.send(data);
      } catch (e) {
        _websocket.onclose = function() {
        };
        _clearState();
        _reconnectWithFallbackTransport(
          "Websocket failed. Downgrading to " + _request.fallbackTransport + " and resending " + message
        );
        _pushAjaxMessage(message);
      }
    }
    function _localMessage(message) {
      var m = JSON.parse(message);
      if (m.id !== guid2) {
        if (typeof _request.onLocalMessage !== "undefined") {
          _request.onLocalMessage(m.event);
        } else if (typeof atmosphere.util.onLocalMessage !== "undefined") {
          atmosphere.util.onLocalMessage(m.event);
        }
      }
    }
    function _prepareCallback(messageBody, state, errorCode, transport) {
      _response.responseBody = messageBody;
      _response.transport = transport;
      _response.status = errorCode;
      _response.state = state;
      _invokeCallback();
    }
    function _readHeaders(xdr, request) {
      if (!request.readResponsesHeaders) {
        if (!request.enableProtocol) {
          request.uuid = guid2;
        }
      } else {
        try {
          var tempUUID = xdr.getResponseHeader("X-Atmosphere-tracking-id");
          if (tempUUID && tempUUID != null) {
            request.uuid = tempUUID.split(" ").pop();
          }
        } catch (e) {
        }
      }
    }
    function _invokeFunction(response) {
      _f(response, _request);
      _f(response, atmosphere.util);
    }
    function _f(response, f) {
      switch (response.state) {
        case "messageReceived":
          _debug("Firing onMessage");
          _requestCount = 0;
          if (typeof f.onMessage !== "undefined")
            f.onMessage(response);
          if (typeof f.onmessage !== "undefined")
            f.onmessage(response);
          break;
        case "error":
          var dbgReasonPhrase = typeof response.reasonPhrase != "undefined" ? response.reasonPhrase : "n/a";
          _debug("Firing onError, reasonPhrase: " + dbgReasonPhrase);
          if (typeof f.onError !== "undefined")
            f.onError(response);
          if (typeof f.onerror !== "undefined")
            f.onerror(response);
          break;
        case "opening":
          delete _request.closed;
          _debug("Firing onOpen");
          if (typeof f.onOpen !== "undefined")
            f.onOpen(response);
          if (typeof f.onopen !== "undefined")
            f.onopen(response);
          break;
        case "messagePublished":
          _debug("Firing messagePublished");
          if (typeof f.onMessagePublished !== "undefined")
            f.onMessagePublished(response);
          break;
        case "re-connecting":
          _debug("Firing onReconnect");
          if (typeof f.onReconnect !== "undefined")
            f.onReconnect(_request, response);
          break;
        case "closedByClient":
          _debug("Firing closedByClient");
          if (typeof f.onClientTimeout !== "undefined")
            f.onClientTimeout(_request);
          break;
        case "re-opening":
          delete _request.closed;
          _debug("Firing onReopen");
          if (typeof f.onReopen !== "undefined")
            f.onReopen(_request, response);
          break;
        case "fail-to-reconnect":
          _debug("Firing onFailureToReconnect");
          if (typeof f.onFailureToReconnect !== "undefined")
            f.onFailureToReconnect(_request, response);
          break;
        case "unsubscribe":
        case "closed":
          var closed = typeof _request.closed !== "undefined" ? _request.closed : false;
          if (!closed) {
            _debug("Firing onClose (" + response.state + " case)");
            if (typeof f.onClose !== "undefined") {
              f.onClose(response);
            }
            if (typeof f.onclose !== "undefined") {
              f.onclose(response);
            }
          } else {
            _debug(
              "Request already closed, not firing onClose (" + response.state + " case)"
            );
          }
          _request.closed = true;
          break;
        case "openAfterResume":
          if (typeof f.onOpenAfterResume !== "undefined")
            f.onOpenAfterResume(_request);
          break;
      }
    }
    function _invokeClose(wasOpen) {
      if (_response.state !== "closed") {
        _response.state = "closed";
        _response.responseBody = "";
        _response.messages = [];
        _response.status = !wasOpen ? 501 : 200;
        _invokeCallback();
      }
    }
    function _invokeCallback() {
      var call = function(index, func) {
        func(_response);
      };
      if (_localStorageService == null && _localSocketF != null) {
        _localSocketF(_response.responseBody);
      }
      _request.reconnect = _request.mrequest;
      var isString = typeof _response.responseBody === "string";
      var messages = isString && _request.trackMessageLength ? _response.messages.length > 0 ? _response.messages : [""] : new Array(_response.responseBody);
      for (var i = 0; i < messages.length; i++) {
        if (messages.length > 1 && messages[i].length === 0) {
          continue;
        }
        _response.responseBody = isString ? atmosphere.util.trim(messages[i]) : messages[i];
        if (_localStorageService == null && _localSocketF != null) {
          _localSocketF(_response.responseBody);
        }
        if (_response.state === "messageReceived") {
          if (_response.responseBody.length === 0) {
            continue;
          } else if (isString && _heartbeatPadding === _response.responseBody) {
            _requestCount = 0;
            continue;
          }
        }
        _invokeFunction(_response);
        if (callbacks.length > 0) {
          if (_canLog("debug")) {
            atmosphere.util.debug(
              "Invoking " + callbacks.length + " global callbacks: " + _response.state
            );
          }
          try {
            atmosphere.util.each(callbacks, call);
          } catch (e) {
            atmosphere.util.log(_request.logLevel, ["Callback exception" + e]);
          }
        }
        if (typeof _request.callback === "function") {
          if (_canLog("debug")) {
            atmosphere.util.debug("Invoking request callbacks");
          }
          try {
            _request.callback(_response);
          } catch (e) {
            atmosphere.util.log(_request.logLevel, ["Callback exception" + e]);
          }
        }
      }
    }
    this.subscribe = function(options2) {
      _subscribe(options2);
      _execute();
    };
    this.execute = function() {
      _execute();
    };
    this.close = function() {
      _close();
    };
    this.disconnect = function() {
      _disconnect();
    };
    this.getUrl = function() {
      return _request.url;
    };
    this.push = function(message, dispatchUrl) {
      if (dispatchUrl != null) {
        var originalDispatchUrl = _request.dispatchUrl;
        _request.dispatchUrl = dispatchUrl;
        _push(message);
        _request.dispatchUrl = originalDispatchUrl;
      } else {
        _push(message);
      }
    };
    this.getUUID = function() {
      return _request.uuid;
    };
    this.pushLocal = function(message) {
      _intraPush(message);
    };
    this.enableProtocol = function() {
      return _request.enableProtocol;
    };
    this.init = function() {
      _init();
    };
    this.request = _request;
    this.response = _response;
  }
};
atmosphere.subscribe = function(url, callback, request) {
  if (typeof callback === "function") {
    atmosphere.addCallback(callback);
  }
  if (typeof url !== "string") {
    request = url;
  } else {
    request.url = url;
  }
  uuid = typeof request !== "undefined" && typeof request.uuid !== "undefined" ? request.uuid : 0;
  var rq = new atmosphere.AtmosphereRequest(request);
  rq.execute();
  requests[requests.length] = rq;
  return rq;
};
atmosphere.unsubscribe = function() {
  if (requests.length > 0) {
    var requestsClone = [].concat(requests);
    for (var i = 0; i < requestsClone.length; i++) {
      var rq = requestsClone[i];
      rq.close();
      clearTimeout(rq.response.request.id);
      if (rq.heartbeatTimer) {
        clearTimeout(rq.heartbeatTimer);
      }
    }
  }
  requests = [];
  callbacks = [];
};
atmosphere.unsubscribeUrl = function(url) {
  var idx = -1;
  if (requests.length > 0) {
    for (var i = 0; i < requests.length; i++) {
      var rq = requests[i];
      if (rq.getUrl() === url) {
        rq.close();
        clearTimeout(rq.response.request.id);
        if (rq.heartbeatTimer) {
          clearTimeout(rq.heartbeatTimer);
        }
        idx = i;
        break;
      }
    }
  }
  if (idx >= 0) {
    requests.splice(idx, 1);
  }
};
atmosphere.addCallback = function(func) {
  if (atmosphere.util.inArray(func, callbacks) === -1) {
    callbacks.push(func);
  }
};
atmosphere.removeCallback = function(func) {
  var index = atmosphere.util.inArray(func, callbacks);
  if (index !== -1) {
    callbacks.splice(index, 1);
  }
};
atmosphere.util = {
  browser: {},
  parseHeaders: function(headerString) {
    var match, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, headers = {};
    while (match = rheaders.exec(headerString)) {
      headers[match[1]] = match[2];
    }
    return headers;
  },
  now: function() {
    return new Date().getTime();
  },
  isArray: function(array) {
    return Object.prototype.toString.call(array) === "[object Array]";
  },
  inArray: function(elem, array) {
    if (!Array.prototype.indexOf) {
      var len = array.length;
      for (var i = 0; i < len; ++i) {
        if (array[i] === elem) {
          return i;
        }
      }
      return -1;
    }
    return array.indexOf(elem);
  },
  isBinary: function(data) {
    return /^\[object\s(?:Blob|ArrayBuffer|.+Array)\]$/.test(
      Object.prototype.toString.call(data)
    );
  },
  isFunction: function(fn) {
    return Object.prototype.toString.call(fn) === "[object Function]";
  },
  getAbsoluteURL: function(url) {
    if (typeof document.createElement === "undefined") {
      return url;
    }
    var div = document.createElement("div");
    div.innerHTML = '<a href="' + url + '"></a>';
    var ua = window.navigator.userAgent;
    if (ua.indexOf("MSIE ") > 0 || ua.indexOf("Trident/") > 0 || ua.indexOf("Edge/") > 0) {
      return atmosphere.util.fixedEncodeURI(decodeURI(div.firstChild.href));
    }
    return div.firstChild.href;
  },
  fixedEncodeURI: function(str) {
    return encodeURI(str).replace(/%5B/g, "[").replace(/%5D/g, "]");
  },
  prepareURL: function(url) {
    var ts = atmosphere.util.now();
    var ret = url.replace(/([?&])_=[^&]*/, "$1_=" + ts);
    return ret + (ret === url ? (/\?/.test(url) ? "&" : "?") + "_=" + ts : "");
  },
  trim: function(str) {
    if (!String.prototype.trim) {
      return str.toString().replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g, "").replace(/\s+/g, " ");
    } else {
      return str.toString().trim();
    }
  },
  param: function(params) {
    var prefix, s = [];
    function add(key, value) {
      value = atmosphere.util.isFunction(value) ? value() : value == null ? "" : value;
      s.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
    }
    function buildParams(prefix2, obj) {
      var name;
      if (atmosphere.util.isArray(obj)) {
        atmosphere.util.each(obj, function(i, v) {
          if (/\[\]$/.test(prefix2)) {
            add(prefix2, v);
          } else {
            buildParams(
              prefix2 + "[" + (typeof v === "object" ? i : "") + "]",
              v
            );
          }
        });
      } else if (Object.prototype.toString.call(obj) === "[object Object]") {
        for (name in obj) {
          buildParams(prefix2 + "[" + name + "]", obj[name]);
        }
      } else {
        add(prefix2, obj);
      }
    }
    for (prefix in params) {
      buildParams(prefix, params[prefix]);
    }
    return s.join("&").replace(/%20/g, "+");
  },
  storage: function() {
    try {
      return !!(window.localStorage && window.StorageEvent);
    } catch (e) {
      return false;
    }
  },
  iterate: function(fn, interval) {
    var timeoutId;
    interval = interval || 0;
    (function loop() {
      timeoutId = setTimeout(function() {
        if (fn() === false) {
          return;
        }
        loop();
      }, interval);
    })();
    return function() {
      clearTimeout(timeoutId);
    };
  },
  each: function(obj, callback, args) {
    if (!obj)
      return;
    var value, i = 0, length = obj.length, isArray = atmosphere.util.isArray(obj);
    if (args) {
      if (isArray) {
        for (; i < length; i++) {
          value = callback.apply(obj[i], args);
          if (value === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          value = callback.apply(obj[i], args);
          if (value === false) {
            break;
          }
        }
      }
    } else {
      if (isArray) {
        for (; i < length; i++) {
          value = callback.call(obj[i], i, obj[i]);
          if (value === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          value = callback.call(obj[i], i, obj[i]);
          if (value === false) {
            break;
          }
        }
      }
    }
    return obj;
  },
  extend: function(target) {
    var i, options, name;
    for (i = 1; i < arguments.length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          target[name] = options[name];
        }
      }
    }
    return target;
  },
  on: function(elem, type, fn) {
    if (elem.addEventListener) {
      elem.addEventListener(type, fn, false);
    } else if (elem.attachEvent) {
      elem.attachEvent("on" + type, fn);
    }
  },
  off: function(elem, type, fn) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, fn, false);
    } else if (elem.detachEvent) {
      elem.detachEvent("on" + type, fn);
    }
  },
  log: function(level, args) {
    if (window.console) {
      var logger = window.console[level];
      if (typeof logger === "function") {
        logger.apply(window.console, args);
      }
    }
  },
  warn: function() {
    atmosphere.util.log("warn", arguments);
  },
  info: function() {
    atmosphere.util.log("info", arguments);
  },
  debug: function() {
    atmosphere.util.log("debug", arguments);
  },
  error: function() {
    atmosphere.util.log("error", arguments);
  },
  xhr: function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e1) {
      try {
        return new window.ActiveXObject("Microsoft.XMLHTTP");
      } catch (e2) {
      }
    }
  },
  checkCORSSupport: function() {
    if (atmosphere.util.browser.msie && !window.XDomainRequest && +atmosphere.util.browser.version.split(".")[0] < 11) {
      return true;
    } else if (atmosphere.util.browser.opera && +atmosphere.util.browser.version.split(".") < 12) {
      return true;
    } else if (atmosphere.util.trim(navigator.userAgent).slice(0, 16) === "KreaTVWebKit/531") {
      return true;
    } else if (atmosphere.util.trim(navigator.userAgent).slice(-7).toLowerCase() === "kreatel") {
      return true;
    }
    var ua = navigator.userAgent.toLowerCase();
    var androidVersionMatches = ua.match(/.+android ([0-9]{1,2})/i), majorVersion = parseInt(
      androidVersionMatches && androidVersionMatches[0] || -1,
      10
    );
    if (!isNaN(majorVersion) && majorVersion > -1 && majorVersion < 3) {
      return true;
    }
    return false;
  }
};
guid = atmosphere.util.now();
(function() {
  var ua = navigator.userAgent.toLowerCase(), match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || /(msie) ([\w.]+)/.exec(ua) || /(trident)(?:.*? rv:([\w.]+)|)/.exec(ua) || ua.indexOf("android") < 0 && /version\/(.+) (safari)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || [];
  if (match[2] === "safari") {
    match[2] = match[1];
    match[1] = "safari";
  }
  atmosphere.util.browser[match[1] || ""] = true;
  atmosphere.util.browser.version = match[2] || "0";
  atmosphere.util.browser.vmajor = atmosphere.util.browser.version.split(".")[0];
  if (atmosphere.util.browser.trident) {
    atmosphere.util.browser.msie = true;
  }
  if (atmosphere.util.browser.msie || atmosphere.util.browser.mozilla && +atmosphere.util.browser.version.split(".")[0] === 1) {
    atmosphere.util.storage = false;
  }
})();
atmosphere.callbacks = {
  unload: function() {
    atmosphere.util.debug(new Date() + " Atmosphere: unload event");
    atmosphere.unsubscribe();
  },
  beforeUnload: function() {
    atmosphere.util.debug(new Date() + " Atmosphere: beforeunload event");
    if (atmosphere._beforeUnloadTimeoutId != null) {
      clearTimeout(atmosphere._beforeUnloadTimeoutId);
    }
    atmosphere._beforeUnloadState = true;
    atmosphere._beforeUnloadTimeoutId = setTimeout(function() {
      atmosphere.util.debug(
        new Date() + " Atmosphere: beforeunload event timeout reached. Reset _beforeUnloadState flag"
      );
      atmosphere._beforeUnloadState = false;
    }, 5e3);
  },
  offline: function() {
    atmosphere.util.debug(new Date() + " Atmosphere: offline event");
    offline = true;
    if (requests.length > 0) {
      var requestsClone = [].concat(requests);
      for (var i = 0; i < requestsClone.length; i++) {
        var rq = requestsClone[i];
        if (rq.request.handleOnlineOffline) {
          rq.close();
          clearTimeout(rq.response.request.id);
          if (rq.heartbeatTimer) {
            clearTimeout(rq.heartbeatTimer);
          }
        }
      }
    }
  },
  online: function() {
    atmosphere.util.debug(new Date() + " Atmosphere: online event");
    if (requests.length > 0) {
      for (var i = 0; i < requests.length; i++) {
        if (requests[i].request.handleOnlineOffline) {
          requests[i].init();
          requests[i].execute();
        }
      }
    }
    offline = false;
  }
};
atmosphere.bindEvents = function() {
  atmosphere.util.on(window, "unload", atmosphere.callbacks.unload);
  atmosphere.util.on(window, "beforeunload", atmosphere.callbacks.beforeUnload);
  atmosphere.util.on(window, "offline", atmosphere.callbacks.offline);
  atmosphere.util.on(window, "online", atmosphere.callbacks.online);
};
atmosphere.unbindEvents = function() {
  atmosphere.util.off(window, "unload", atmosphere.callbacks.unload);
  atmosphere.util.off(
    window,
    "beforeunload",
    atmosphere.callbacks.beforeUnload
  );
  atmosphere.util.off(window, "offline", atmosphere.callbacks.offline);
  atmosphere.util.off(window, "online", atmosphere.callbacks.online);
};
atmosphere.bindEvents();

// node_modules/@hilla/frontend/FluxConnection.js
var State;
(function(State2) {
  State2["ACTIVE"] = "active";
  State2["INACTIVE"] = "inactive";
})(State || (State = {}));
var FluxConnection = class extends EventTarget {
  constructor() {
    var _a2, _b;
    super();
    Object.defineProperty(this, "nextId", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "endpointInfos", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    Object.defineProperty(this, "onNextCallbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    Object.defineProperty(this, "onCompleteCallbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    Object.defineProperty(this, "onErrorCallbacks", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /* @__PURE__ */ new Map()
    });
    Object.defineProperty(this, "socket", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "state", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: State.INACTIVE
    });
    Object.defineProperty(this, "pendingMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    if (!((_b = (_a2 = window.Vaadin) === null || _a2 === void 0 ? void 0 : _a2.featureFlags) === null || _b === void 0 ? void 0 : _b.hillaPush)) {
      throw new Error(`Push support in Hilla is not enabled. Enable it in the debug window or by adding com.vaadin.experimental.hillaPush=true to vaadin-featureflags.properties`);
    }
    this.connectWebsocket();
  }
  connectWebsocket() {
    const extraHeaders = getCsrfTokenHeadersForEndpointRequest(document);
    const callback = {
      onMessage: (response) => {
        this.handleMessage(JSON.parse(response.responseBody));
      },
      onOpen: (_response) => {
        if (this.state === State.INACTIVE) {
          this.state = State.ACTIVE;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } }));
          this.sendPendingMessages();
        }
      },
      onReopen: (_response) => {
        if (this.state === State.INACTIVE) {
          this.state = State.ACTIVE;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: true } }));
          this.sendPendingMessages();
        }
      },
      onClose: (_response) => {
        if (this.state === State.ACTIVE) {
          this.state = State.INACTIVE;
          this.dispatchEvent(new CustomEvent("state-changed", { detail: { active: false } }));
        }
      },
      onError: (response) => {
        console.error("error in push communication", response);
      }
    };
    this.socket = atmosphere.subscribe({
      url: "/HILLA/push",
      transport: "websocket",
      fallbackTransport: "long-polling",
      contentType: "application/json; charset=UTF-8",
      reconnectInterval: 5e3,
      timeout: -1,
      maxReconnectOnClose: 1e7,
      trackMessageLength: true,
      enableProtocol: true,
      headers: extraHeaders,
      ...callback
    });
  }
  handleMessage(message) {
    const { id } = message;
    const endpointInfo = this.endpointInfos.get(id);
    if (message["@type"] === "update") {
      const callback = this.onNextCallbacks.get(id);
      if (callback) {
        callback(message.item);
      }
    } else if (message["@type"] === "complete") {
      const callback = this.onCompleteCallbacks.get(id);
      if (callback) {
        callback();
      }
      this.removeSubscription(id);
    } else if (message["@type"] === "error") {
      const callback = this.onErrorCallbacks.get(id);
      if (callback) {
        callback();
      }
      this.removeSubscription(id);
      if (!callback) {
        throw new Error(`Error in ${endpointInfo}: ${message.message}`);
      }
    } else {
      throw new Error(`Unknown message from server: ${message}`);
    }
  }
  removeSubscription(id) {
    this.onNextCallbacks.delete(id);
    this.onCompleteCallbacks.delete(id);
    this.onErrorCallbacks.delete(id);
    this.endpointInfos.delete(id);
  }
  sendPendingMessages() {
    this.pendingMessages.forEach((msg) => this.send(msg));
    this.pendingMessages = [];
  }
  send(message) {
    if (this.state === State.INACTIVE) {
      this.pendingMessages.push(message);
    } else {
      this.socket.push(JSON.stringify(message));
    }
  }
  subscribe(endpointName, methodName, parameters) {
    const id = this.nextId.toString();
    this.nextId += 1;
    const params = parameters || [];
    const msg = { "@type": "subscribe", id, endpointName, methodName, params };
    const endpointInfo = `${endpointName}.${methodName}(${JSON.stringify(params)})`;
    this.send(msg);
    this.endpointInfos.set(id, endpointInfo);
    const hillaSubscription = {
      onNext: (callback) => {
        this.onNextCallbacks.set(id, callback);
        return hillaSubscription;
      },
      onComplete: (callback) => {
        this.onCompleteCallbacks.set(id, callback);
        return hillaSubscription;
      },
      onError: (callback) => {
        this.onErrorCallbacks.set(id, callback);
        return hillaSubscription;
      },
      cancel: () => {
        if (!this.endpointInfos.has(id)) {
          return;
        }
        const closeMessage = { "@type": "unsubscribe", id };
        this.send(closeMessage);
        this.removeSubscription(id);
      },
      context: (context) => {
        context.addController({
          hostDisconnected: () => {
            hillaSubscription.cancel();
          }
        });
        return hillaSubscription;
      }
    };
    return hillaSubscription;
  }
};

// node_modules/@hilla/frontend/Connect.js
var $wnd3 = window;
$wnd3.Vaadin = $wnd3.Vaadin || {};
$wnd3.Vaadin.registrations = $wnd3.Vaadin.registrations || [];
$wnd3.Vaadin.registrations.push({
  is: "endpoint"
});
var EndpointError = class extends Error {
  constructor(message, type, detail) {
    super(message);
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "detail", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.type = type;
    this.detail = detail;
  }
};
var EndpointValidationError = class extends EndpointError {
  constructor(message, validationErrorData, type) {
    super(message, type, validationErrorData);
    Object.defineProperty(this, "validationErrorMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "validationErrorData", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.validationErrorMessage = message;
    this.detail = null;
    this.validationErrorData = validationErrorData;
  }
};
var EndpointResponseError = class extends EndpointError {
  constructor(message, response) {
    super(message, "EndpointResponseError", response);
    Object.defineProperty(this, "response", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.response = response;
  }
  get status() {
    return this.response.status;
  }
};
var UnauthorizedResponseError = class extends EndpointResponseError {
  constructor(message, response) {
    super(message, response);
    this.type = "UnauthorizedResponseError";
  }
};
var ForbiddenResponseError = class extends EndpointResponseError {
  constructor(message, response) {
    super(message, response);
    this.type = "ForbiddenResponseError";
  }
};
var throwConnectException = (errorJson) => {
  if (errorJson.validationErrorData) {
    throw new EndpointValidationError(errorJson.message, errorJson.validationErrorData, errorJson.type);
  } else {
    throw new EndpointError(errorJson.message, errorJson.type, errorJson.detail);
  }
};
var assertResponseIsOk = async (response) => {
  if (!response.ok) {
    const errorText = await response.text();
    let errorJson;
    try {
      errorJson = JSON.parse(errorText);
    } catch (ignored) {
      errorJson = null;
    }
    if (errorJson !== null) {
      throwConnectException(errorJson);
    } else if (errorText !== null && errorText.length > 0) {
      throw new EndpointResponseError(errorText, response);
    } else {
      const message = `expected "200 OK" response, but got ${response.status} ${response.statusText}`;
      switch (response.status) {
        case 401:
          throw new UnauthorizedResponseError(message, response);
        case 403:
          throw new ForbiddenResponseError(message, response);
        default:
          throw new EndpointResponseError(message, response);
      }
    }
  }
};
var ValidationErrorData = class {
  constructor(message, parameterName) {
    Object.defineProperty(this, "message", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parameterName", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.message = message;
    this.parameterName = parameterName;
  }
};
function isFlowLoaded() {
  var _a2, _b;
  return ((_b = (_a2 = $wnd3.Vaadin.Flow) === null || _a2 === void 0 ? void 0 : _a2.clients) === null || _b === void 0 ? void 0 : _b.TypeScript) !== void 0;
}
var ConnectClient = class {
  constructor(options = {}) {
    Object.defineProperty(this, "prefix", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "/connect"
    });
    Object.defineProperty(this, "middlewares", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "_fluxConnection", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    if (options.prefix) {
      this.prefix = options.prefix;
    }
    if (options.middlewares) {
      this.middlewares = options.middlewares;
    }
    ConnectionIndicator.create();
    $wnd3.addEventListener("online", () => {
      if (!isFlowLoaded()) {
        $wnd3.Vaadin.connectionState.state = ConnectionState.CONNECTED;
      }
    });
    $wnd3.addEventListener("offline", () => {
      if (!isFlowLoaded()) {
        $wnd3.Vaadin.connectionState.state = ConnectionState.CONNECTION_LOST;
      }
    });
  }
  async call(endpoint, method, params, __init) {
    if (arguments.length < 2) {
      throw new TypeError(`2 arguments required, but got only ${arguments.length}`);
    }
    const csrfHeaders = getCsrfTokenHeadersForEndpointRequest(document);
    const headers = {
      Accept: "application/json",
      "Content-Type": "application/json",
      ...csrfHeaders
    };
    const nullForUndefined = (obj) => Object.keys(obj).reduce((_obj, property2) => {
      if (_obj[property2] === void 0) {
        _obj[property2] = null;
      }
      return _obj;
    }, obj);
    const request = new Request(`${this.prefix}/${endpoint}/${method}`, {
      method: "POST",
      headers,
      body: params !== void 0 ? JSON.stringify(nullForUndefined(params)) : void 0
    });
    const initialContext = {
      endpoint,
      method,
      params,
      request
    };
    const responseHandlerMiddleware = async (context, next) => {
      const response = await next(context);
      await assertResponseIsOk(response);
      const text = await response.text();
      return JSON.parse(text, (_, value) => value === null ? void 0 : value);
    };
    const fetchNext = async (context) => {
      $wnd3.Vaadin.connectionState.loadingStarted();
      return fetch(context.request, { signal: __init === null || __init === void 0 ? void 0 : __init.signal }).then((response) => {
        $wnd3.Vaadin.connectionState.loadingFinished();
        return response;
      }).catch((error) => {
        if (error.name === "AbortError") {
          $wnd3.Vaadin.connectionState.loadingFinished();
        } else {
          $wnd3.Vaadin.connectionState.loadingFailed();
        }
        return Promise.reject(error);
      });
    };
    const middlewares = [responseHandlerMiddleware].concat(this.middlewares);
    const chain = middlewares.reduceRight(
      (next, middleware) => {
        return (context) => {
          if (typeof middleware === "function") {
            return middleware(context, next);
          }
          return middleware.invoke(context, next);
        };
      },
      fetchNext
    );
    return chain(initialContext);
  }
  subscribe(endpoint, method, params) {
    return this.fluxConnection.subscribe(endpoint, method, params ? Object.values(params) : []);
  }
  get fluxConnection() {
    if (!this._fluxConnection) {
      this._fluxConnection = new FluxConnection();
    }
    return this._fluxConnection;
  }
};

// node_modules/@hilla/frontend/index.js
var $wnd4 = window;
$wnd4.Vaadin = $wnd4.Vaadin || {};
$wnd4.Vaadin.registrations = $wnd4.Vaadin.registrations || [];
$wnd4.Vaadin.registrations.push({
  is: "@hilla/frontend",
  version: "1.3.5"
});
export {
  ConnectClient,
  EndpointError,
  EndpointResponseError,
  EndpointValidationError,
  FluxConnection,
  ForbiddenResponseError,
  InvalidSessionMiddleware,
  State,
  UnauthorizedResponseError,
  ValidationErrorData,
  login,
  logout
};
//# sourceMappingURL=@hilla_frontend.js.map

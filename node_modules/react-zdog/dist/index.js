import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';
import Zdog from 'zdog';
import React, { useContext, useEffect, useRef, useLayoutEffect, useState, useImperativeHandle } from 'react';
import ResizeObserver from 'resize-observer-polyfill';

const stateContext = React.createContext();
const parentContext = React.createContext();
let globalEffects = [];
function addEffect(callback) {
  globalEffects.push(callback);
}
function invalidate() {// TODO: render loop has to be able to render frames on demand
}
function applyProps(instance, newProps) {
  Zdog.extend(instance, newProps);
}

function useMeasure() {
  const ref = useRef();

  const _useState = useState({
    left: 0,
    top: 0,
    width: 0,
    height: 0
  }),
        bounds = _useState[0],
        set = _useState[1];

  const _useState2 = useState(() => new ResizeObserver((_ref) => {
    let entry = _ref[0];
    return set(entry.contentRect);
  })),
        ro = _useState2[0];

  useEffect(() => {
    if (ref.current) ro.observe(ref.current);
    return () => ro.disconnect();
  }, [ref.current]);
  return [{
    ref
  }, bounds];
}

function useRender(fn, deps) {
  if (deps === void 0) {
    deps = [];
  }

  const state = useContext(stateContext);
  useEffect(() => {
    // Subscribe to the render-loop
    const unsubscribe = state.current.subscribe(fn); // Call subscription off on unmount

    return () => unsubscribe();
  }, deps);
}

function useZdog() {
  const state = useContext(stateContext);
  return state.current;
}

function useZdogPrimitive(primitive, children, props, ref) {
  const state = useContext(stateContext);
  const parent = useContext(parentContext);

  const _useState3 = useState(() => new primitive(props)),
        node = _useState3[0];

  useImperativeHandle(ref, () => node);
  useLayoutEffect(() => void applyProps(node, props), [props]);
  useLayoutEffect(() => {
    if (parent) {
      parent.addChild(node);
      state.current.illu.updateGraph();
      return () => {
        parent.removeChild(node);
        parent.updateFlatGraph();
        state.current.illu.updateGraph();
      };
    }
  }, [parent]);
  return [React.createElement(parentContext.Provider, {
    value: node,
    children: children
  }), node];
}

const Illustration = React.memo((_ref2) => {
  let children = _ref2.children,
      style = _ref2.style,
      resize = _ref2.resize,
      _ref2$element = _ref2.element,
      Element = _ref2$element === void 0 ? 'svg' : _ref2$element,
      dragRotate = _ref2.dragRotate,
      rest = _objectWithoutPropertiesLoose(_ref2, ["children", "style", "resize", "element", "dragRotate"]);

  const canvas = useRef();

  const _useMeasure = useMeasure(),
        bind = _useMeasure[0],
        size = _useMeasure[1];

  const _useZdogPrimitive = useZdogPrimitive(Zdog.Anchor, children),
        result = _useZdogPrimitive[0],
        scene = _useZdogPrimitive[1];

  const state = useRef({
    scene,
    illu: undefined,
    size: {},
    subscribers: [],
    subscribe: fn => {
      state.current.subscribers.push(fn);
      return () => state.current.subscribers = state.current.subscribers.filter(s => s !== fn);
    }
  });
  useEffect(() => {
    state.current.size = size;
    if (state.current.illu) state.current.illu.setSize(size.width, size.height);
  }, [size]);
  useEffect(() => {
    state.current.illu = new Zdog.Illustration(_extends({
      element: canvas.current,
      dragRotate
    }, rest));
    state.current.illu.addChild(scene);
    state.current.illu.updateGraph();
    let frame;
    let active = true;

    function render(t) {
      const _state$current = state.current,
            size = _state$current.size,
            subscribers = _state$current.subscribers;

      if (size.width && size.height) {
        // Run global effects
        globalEffects.forEach(fn => fn(t)); // Run local effects

        subscribers.forEach(fn => fn(t)); // Render scene

        state.current.illu.updateRenderGraph();
      }

      if (active) frame = requestAnimationFrame(render);
    } // Start render loop


    render();
    return () => {
      // Take no chances, the loop has got to stop if the component unmounts
      active = false;
      cancelAnimationFrame(frame);
    };
  }, []); // Takes care of updating the main illustration

  useLayoutEffect(() => void (state.current.illu && applyProps(state.current.illu, rest)), [rest]);
  return React.createElement("div", _extends({
    ref: bind.ref
  }, rest, {
    style: _extends({
      position: 'relative',
      width: '100%',
      height: '100%',
      overflow: 'hidden'
    }, style)
  }), React.createElement(Element, {
    ref: canvas,
    style: {
      display: 'block'
    },
    width: size.width,
    height: size.height
  }), state.current.illu && React.createElement(stateContext.Provider, {
    value: state,
    children: result
  }));
});

const createZdog = primitive => React.forwardRef((_ref3, ref) => {
  let children = _ref3.children,
      rest = _objectWithoutPropertiesLoose(_ref3, ["children"]);

  return useZdogPrimitive(primitive, children, rest, ref)[0];
});

const Anchor = createZdog(Zdog.Anchor);
const Shape = createZdog(Zdog.Shape);
const Group = createZdog(Zdog.Group);
const Rect = createZdog(Zdog.Rect);
const RoundedRect = createZdog(Zdog.RoundedRect);
const Ellipse = createZdog(Zdog.Ellipse);
const Polygon = createZdog(Zdog.Polygon);
const Hemisphere = createZdog(Zdog.Hemisphere);
const Cylinder = createZdog(Zdog.Cylinder);
const Cone = createZdog(Zdog.Cone);
const Box = createZdog(Zdog.Box);

export { Anchor, Box, Cone, Cylinder, Ellipse, Group, Hemisphere, Illustration, Polygon, Rect, RoundedRect, Shape, addEffect, applyProps, invalidate, useRender, useZdog };
